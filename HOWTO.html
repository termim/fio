<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. HOWTO &#8212; fio 1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="fio 1 documentation" href="index.html" />
    <link rel="next" title="3. GFIO TODO" href="TODO.html" />
    <link rel="prev" title="1. README" href="README.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="howto">
<h1>2. HOWTO<a class="headerlink" href="#howto" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview-and-history">
<h2>2.1. Overview and history<a class="headerlink" href="#overview-and-history" title="Permalink to this headline">¶</a></h2>
<p>fio was originally written to save me the hassle of writing special test
case programs when I wanted to test a specific workload, either for
performance reasons or to find/reproduce a bug. The process of writing
such a test app can be tiresome, especially if you have to do it often.
Hence I needed a tool that would be able to simulate a given io workload
without resorting to writing a tailored test case again and again.</p>
<p>A test work load is difficult to define, though. There can be any number
of processes or threads involved, and they can each be using their own
way of generating io. You could have someone dirtying large amounts of
memory in an memory mapped file, or maybe several threads issuing
reads using asynchronous io. fio needed to be flexible enough to
simulate both of these cases, and many more.</p>
</div>
<div class="section" id="how-fio-works">
<h2>2.2. How fio works<a class="headerlink" href="#how-fio-works" title="Permalink to this headline">¶</a></h2>
<p>The first step in getting fio to simulate a desired io workload, is
writing a job file describing that specific setup. A job file may contain
any number of threads and/or files - the typical contents of the job file
is a global section defining shared parameters, and one or more job
sections describing the jobs involved. When run, fio parses this file
and sets everything up as described. If we break down a job from top to
bottom, it contains the following basic parameters:</p>
<dl class="docutils">
<dt>IO type</dt>
<dd>Defines the io pattern issued to the file(s).
We may only be reading sequentially from this
file(s), or we may be writing randomly. Or even
mixing reads and writes, sequentially or randomly.</dd>
<dt>Block size</dt>
<dd>In how large chunks are we issuing io? This may be
a single value, or it may describe a range of
block sizes.</dd>
<dt>IO size</dt>
<dd>How much data are we going to be reading/writing.</dd>
<dt>IO engine</dt>
<dd>How do we issue io? We could be memory mapping the
file, we could be using regular read/write, we
could be using splice, async io, or even SG
(SCSI generic sg).</dd>
<dt>IO depth</dt>
<dd>If the io engine is async, how large a queuing
depth do we want to maintain?</dd>
<dt>IO type</dt>
<dd>Should we be doing buffered io, or direct/raw io?</dd>
<dt>Num files</dt>
<dd>How many files are we spreading the workload over.</dd>
<dt>Num threads</dt>
<dd>How many threads or processes should we spread
this workload over.</dd>
</dl>
<p>The above are the basic parameters defined for a workload, in addition
there&#8217;s a multitude of parameters that modify other aspects of how this
job behaves.</p>
</div>
<div class="section" id="running-fio">
<h2>2.3. Running fio<a class="headerlink" href="#running-fio" title="Permalink to this headline">¶</a></h2>
<p>See the <a class="reference internal" href="README.html"><span class="doc">README</span></a> file for command line parameters, there are only a few
of them.</p>
<p>Running fio is normally the easiest part - you just give it the job file
(or job files) as parameters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ fio job_file
</pre></div>
</div>
<p>and it will start doing what the job_file tells it to do. You can give
more than one job file on the command line, fio will serialize the running
of those files. Internally that is the same as using the &#8216;stonewall&#8217;
parameter described in the parameter section.</p>
<p>If the job file contains only one job, you may as well just give the
parameters on the command line. The command line parameters are identical
to the job parameters, with a few extra that control global parameters
(see <a class="reference internal" href="README.html"><span class="doc">README</span></a>). For example, for the job file parameter <cite>iodepth=2</cite>, the
mirror command line option would be <cite>&#8211;iodepth 2</cite> or <cite>&#8211;iodepth=2</cite>. You can
also use the command line for giving more than one job entry. For each
<cite>&#8211;name</cite> option that fio sees, it will start a new job with that name.
Command line entries following a <cite>&#8211;name</cite> entry will apply to that job,
until there are no more entries or a new <cite>&#8211;name</cite> entry is seen. This is
similar to the job file options, where each option applies to the current
job until a new [] job entry is seen.</p>
<p>fio does not need to run as root, except if the files or devices specified
in the job section requires that. Some other options may also be restricted,
such as memory locking, io scheduler switching, and decreasing the nice value.</p>
</div>
<div class="section" id="job-file-format">
<h2>2.4. Job file format<a class="headerlink" href="#job-file-format" title="Permalink to this headline">¶</a></h2>
<p>As previously described, fio accepts one or more job files describing
what it is supposed to do. The job file format is the classic ini file,
where the names enclosed in [] brackets define the job name. You are free
to use any ascii name you want, except <cite>global</cite> which has special meaning.
A global section sets defaults for the jobs described in that file. A job
may override a global section parameter, and a job file may even have
several global sections if so desired. A job is only affected by a global
section residing above it. If the first character in a line is a &#8216;;&#8217; or a
&#8216;#&#8217;, the entire line is discarded as a comment.</p>
<p>So let&#8217;s look at a really simple job file that defines two processes, each
randomly reading from a 128MB file.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">--</span> <span class="n">start</span> <span class="n">job</span> <span class="n">file</span> <span class="o">--</span>
<span class="p">[</span><span class="k">global</span><span class="p">]</span>
<span class="n">rw</span><span class="o">=</span><span class="n">randread</span>
<span class="n">size</span><span class="o">=</span><span class="mi">128</span><span class="n">m</span>

<span class="p">[</span><span class="n">job1</span><span class="p">]</span>

<span class="p">[</span><span class="n">job2</span><span class="p">]</span>

<span class="p">;</span> <span class="o">--</span> <span class="n">end</span> <span class="n">job</span> <span class="n">file</span> <span class="o">--</span>
</pre></div>
</div>
<p>As you can see, the job file sections themselves are empty as all the
described parameters are shared. As no <cite>filename=</cite> option is given, fio
makes up a <cite>filename</cite> for each of the jobs as it sees fit. On the command
line, this job would look as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ fio --name=global --rw=randread --size=128m --name=job1 --name=job2
</pre></div>
</div>
<p>Let&#8217;s look at an example that has a number of processes writing randomly
to files.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">--</span> <span class="n">start</span> <span class="n">job</span> <span class="n">file</span> <span class="o">--</span>
<span class="p">[</span><span class="n">random</span><span class="o">-</span><span class="n">writers</span><span class="p">]</span>
<span class="n">ioengine</span><span class="o">=</span><span class="n">libaio</span>
<span class="n">iodepth</span><span class="o">=</span><span class="mi">4</span>
<span class="n">rw</span><span class="o">=</span><span class="n">randwrite</span>
<span class="n">bs</span><span class="o">=</span><span class="mi">32</span><span class="n">k</span>
<span class="n">direct</span><span class="o">=</span><span class="mi">0</span>
<span class="n">size</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span>
<span class="n">numjobs</span><span class="o">=</span><span class="mi">4</span>

<span class="p">;</span> <span class="o">--</span> <span class="n">end</span> <span class="n">job</span> <span class="n">file</span> <span class="o">--</span>
</pre></div>
</div>
<p>Here we have no global section, as we only have one job defined anyway.
We want to use async io here, with a depth of 4 for each file. We also
increased the buffer size used to 32KB and define numjobs to 4 to
fork 4 identical jobs. The result is 4 processes each randomly writing
to their own 64MB file. Instead of using the above job file, you could
have given the parameters on the command line. For this case, you would
specify:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ fio --name=random-writers --ioengine=libaio --iodepth=4 --rw=randwrite --bs=32k --direct=0 --size=64m --numjobs=4
</pre></div>
</div>
<p>When fio is utilized as a basis of any reasonably large test suite, it might be
desirable to share a set of standardized settings across multiple job files.
Instead of copy/pasting such settings, any section may pull in an external
.fio file with &#8216;include filename&#8217; directive, as in the following example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">--</span> <span class="n">start</span> <span class="n">job</span> <span class="n">file</span> <span class="n">including</span><span class="o">.</span><span class="n">fio</span> <span class="o">--</span>
<span class="p">[</span><span class="k">global</span><span class="p">]</span>
<span class="n">filename</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">test</span>
<span class="n">filesize</span><span class="o">=</span><span class="mi">1</span><span class="n">m</span>
<span class="n">include</span> <span class="n">glob</span><span class="o">-</span><span class="n">include</span><span class="o">.</span><span class="n">fio</span>

<span class="p">[</span><span class="n">test</span><span class="p">]</span>
<span class="n">rw</span><span class="o">=</span><span class="n">randread</span>
<span class="n">bs</span><span class="o">=</span><span class="mi">4</span><span class="n">k</span>
<span class="n">time_based</span><span class="o">=</span><span class="mi">1</span>
<span class="n">runtime</span><span class="o">=</span><span class="mi">10</span>
<span class="n">include</span> <span class="n">test</span><span class="o">-</span><span class="n">include</span><span class="o">.</span><span class="n">fio</span>
<span class="p">;</span> <span class="o">--</span> <span class="n">end</span> <span class="n">job</span> <span class="n">file</span> <span class="n">including</span><span class="o">.</span><span class="n">fio</span> <span class="o">--</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">--</span> <span class="n">start</span> <span class="n">job</span> <span class="n">file</span> <span class="n">glob</span><span class="o">-</span><span class="n">include</span><span class="o">.</span><span class="n">fio</span> <span class="o">--</span>
<span class="n">thread</span><span class="o">=</span><span class="mi">1</span>
<span class="n">group_reporting</span><span class="o">=</span><span class="mi">1</span>
<span class="p">;</span> <span class="o">--</span> <span class="n">end</span> <span class="n">job</span> <span class="n">file</span> <span class="n">glob</span><span class="o">-</span><span class="n">include</span><span class="o">.</span><span class="n">fio</span> <span class="o">--</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">--</span> <span class="n">start</span> <span class="n">job</span> <span class="n">file</span> <span class="n">test</span><span class="o">-</span><span class="n">include</span><span class="o">.</span><span class="n">fio</span> <span class="o">--</span>
<span class="n">ioengine</span><span class="o">=</span><span class="n">libaio</span>
<span class="n">iodepth</span><span class="o">=</span><span class="mi">4</span>
<span class="p">;</span> <span class="o">--</span> <span class="n">end</span> <span class="n">job</span> <span class="n">file</span> <span class="n">test</span><span class="o">-</span><span class="n">include</span><span class="o">.</span><span class="n">fio</span> <span class="o">--</span>
</pre></div>
</div>
<p>Settings pulled into a section apply to that section only (except global
section). Include directives may be nested in that any included file may
contain further include directive(s). Include files may not contain []
sections.</p>
<div class="section" id="environment-variables">
<h3>2.4.1. Environment variables<a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h3>
<p>fio also supports environment variable expansion in job files. Any
sub-string of the form &#8220;${VARNAME}&#8221; as part of an option value (in other
words, on the right of the &#8216;=&#8217;), will be expanded to the value of the
environment variable called VARNAME.  If no such environment variable
is defined, or VARNAME is the empty string, the empty string will be
substituted.</p>
<p>As an example, let&#8217;s look at a sample fio invocation and job file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ SIZE=64m NUMJOBS=4 fio jobfile.fio
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>; -- start job file --
[random-writers]
rw=randwrite
size=${SIZE}
numjobs=${NUMJOBS}
; -- end job file --
</pre></div>
</div>
<p>This will expand to the following equivalent job file at runtime:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="o">--</span> <span class="n">start</span> <span class="n">job</span> <span class="n">file</span> <span class="o">--</span>
<span class="p">[</span><span class="n">random</span><span class="o">-</span><span class="n">writers</span><span class="p">]</span>
<span class="n">rw</span><span class="o">=</span><span class="n">randwrite</span>
<span class="n">size</span><span class="o">=</span><span class="mi">64</span><span class="n">m</span>
<span class="n">numjobs</span><span class="o">=</span><span class="mi">4</span>
<span class="p">;</span> <span class="o">--</span> <span class="n">end</span> <span class="n">job</span> <span class="n">file</span> <span class="o">--</span>
</pre></div>
</div>
<p>fio ships with a few example job files, you can also look there for
inspiration.</p>
</div>
<div class="section" id="reserved-keywords">
<h3>2.4.2. Reserved keywords<a class="headerlink" href="#reserved-keywords" title="Permalink to this headline">¶</a></h3>
<p>Additionally, fio has a set of reserved keywords that will be replaced
internally with the appropriate value. Those keywords are:</p>
<ul class="simple">
<li><strong>$pagesize</strong> -       The architecture page size of the running system</li>
<li><strong>$mb_memory</strong> -      Megabytes of total memory in the system</li>
<li><strong>$ncpus</strong> -          Number of online available CPUs</li>
</ul>
<p>These can be used on the command line or in the job file, and will be
automatically substituted with the current system values when the job
is run. Simple math is also supported on these keywords, so you can
perform actions like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>size=8*$mb_memory
</pre></div>
</div>
<p>and get that properly expanded to 8 times the size of memory in the
machine.</p>
</div>
</div>
<div class="section" id="detailed-list-of-parameters">
<h2>2.5. Detailed list of parameters<a class="headerlink" href="#detailed-list-of-parameters" title="Permalink to this headline">¶</a></h2>
<p>This section describes in details each parameter associated with a job.
Some parameters take an option of a given type, such as an integer or
a string. Anywhere a numeric value is required, an arithmetic expression
may be used, provided it is surrounded by parentheses. Supported operators
are:</p>
<blockquote>
<div><ul class="simple">
<li>addition (+)</li>
<li>subtraction (-)</li>
<li>multiplication (*)</li>
<li>division (/)</li>
<li>modulus (%)</li>
<li>exponentiation (^)</li>
</ul>
</div></blockquote>
<p>For time values in expressions, units are microseconds by default. This is
different than for time values not in expressions (not enclosed in
parentheses). The following types are used:</p>
<dl class="docutils">
<dt><strong>str</strong></dt>
<dd>String. This is a sequence of alpha characters.</dd>
<dt><strong>time</strong></dt>
<dd>Integer with possible time suffix. In seconds unless otherwise
specified, use eg 10m for 10 minutes. Accepts s/m/h for seconds,
minutes, and hours, and accepts &#8216;ms&#8217; (or &#8216;msec&#8217;) for milliseconds,
and &#8216;us&#8217; (or &#8216;usec&#8217;) for microseconds.</dd>
<dt><strong>int</strong></dt>
<dd>SI integer. A whole number value, which may contain a suffix
describing the base of the number. Accepted suffixes are k/m/g/t/p,
meaning kilo, mega, giga, tera, and peta. The suffix is not case
sensitive, and you may also include trailing &#8216;b&#8217; (eg &#8216;kb&#8217; is the same
as &#8216;k&#8217;). So if you want to specify 4096, you could either write
out &#8216;4096&#8217; or just give 4k. The suffixes signify base 2 values, so
1024 is 1k and 1024k is 1m and so on, unless the suffix is explicitly
set to a base 10 value using &#8216;kib&#8217;, &#8216;mib&#8217;, &#8216;gib&#8217;, etc. If that is the
case, then 1000 is used as the multiplier. This can be handy for
disks, since manufacturers generally use base 10 values when listing
the capacity of a drive. If the option accepts an upper and lower
range, use a colon &#8216;:&#8217; or minus &#8216;-&#8216; to separate such values.  May also
include a prefix to indicate numbers base. If 0x is used, the number
is assumed to be hexadecimal.  See irange.</dd>
<dt><strong>bool</strong></dt>
<dd>Boolean. Usually parsed as an integer, however only defined for
true and false (1 and 0).</dd>
<dt><strong>irange</strong></dt>
<dd>Integer range with suffix. Allows value range to be given, such
as 1024-4096. A colon may also be used as the separator, eg
1k:4k. If the option allows two sets of ranges, they can be
specified with a &#8216;,&#8217; or &#8216;/&#8217; delimiter: 1k-4k/8k-32k. Also see
int.</dd>
<dt><strong>float_list</strong></dt>
<dd>A list of floating point numbers, separated by a &#8216;:&#8217; character.</dd>
</dl>
<p>With the above in mind, here follows the complete list of fio job
parameters.</p>
<dl class="option">
<dt id="cmdoption-arg-name">
<code class="descname">name</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-name" title="Permalink to this definition">¶</a></dt>
<dd><p>ASCII name of the job. This may be used to override the
name printed by fio for this job. Otherwise the job
name is used. On the command line this parameter has the
special purpose of also signaling the start of a new
job.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-wait_for">
<code class="descname">wait_for</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-wait_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the already defined job to wait
for. Single waitee name only may be specified. If set, the job
won&#8217;t be started until all workers of the waitee job are done.</p>
<p>Wait_for operates on the job name basis, so there are a few
limitations. First, the waitee must be defined prior to the
waiter job (meaning no forward references). Second, if a job
is being referenced as a waitee, it must have a unique name
(no duplicate waitees).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-description">
<code class="descname">description</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-description" title="Permalink to this definition">¶</a></dt>
<dd><p>Text description of the job. Doesn&#8217;t do anything except
dump this text description when this job is run. It&#8217;s
not parsed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-directory">
<code class="descname">directory</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Prefix filenames with this directory. Used to place files
in a different location than &#8221;./&#8221;. See the <a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a> option
for escaping certain characters.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-filename">
<code class="descname">filename</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio normally makes up a filename based on the job name,
thread number, and file number. If you want to share
files between threads in a job or several jobs, specify
a filename for each of them to override the default.
If the ioengine is file based, you can specify a number of
files by separating the names with a &#8216;:&#8217; colon. So if you
wanted a job to open /dev/sda and /dev/sdb as the two working
files, you would use filename=/dev/sda:/dev/sdb. On Windows,
disk devices are accessed as \.PhysicalDrive0 for the first
device, \.PhysicalDrive1 for the second etc. Note: Windows
and FreeBSD prevent write access to areas of the disk
containing in-use data (e.g. filesystems).
If the wanted filename does need to include a colon, then
escape that with a &#8216;&#8217; character. For instance, if the filename
is &#8220;/dev/dsk/foo&#64;3,0:c&#8221;, then you would use
filename=&#8221;/dev/dsk/foo&#64;3,0:c&#8221;. &#8216;-&#8216; is a reserved name, meaning
stdin or stdout. Which of the two depends on the read/write
direction set.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-filename_format">
<code class="descname">filename_format</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-filename_format" title="Permalink to this definition">¶</a></dt>
<dd><p>If sharing multiple files between jobs, it is usually necessary
to  have fio generate the exact names that you want. By default,
fio will name a file based on the default file format
specification of jobname.jobnumber.filenumber. With this
option, that can be customized. Fio will recognize and replace
the following keywords in this string:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">$jobname</span></code></dt>
<dd>The name of the worker thread or process.</dd>
<dt><code class="docutils literal"><span class="pre">$jobnum</span></code></dt>
<dd>The incremental number of the worker thread or
process.</dd>
<dt><code class="docutils literal"><span class="pre">$filenum</span></code></dt>
<dd>The incremental number of the file for that worker
thread or process.</dd>
</dl>
<p>To have dependent jobs share a set of files, this option can
be set to have fio generate filenames that are shared between
the two. For instance, if testfiles.$filenum is specified,
file number 4 for any job will be named testfiles.4. The
default of $jobname.$jobnum.$filenum will be used if
no other format specifier is given.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unique_filename">
<code class="descname">unique_filename</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unique_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>To avoid collisions between networked clients, fio
defaults to prefixing any generated filenames (with a directory
specified) with the source of the client connecting. To disable
this behavior, set this option to 0.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-opendir">
<code class="descname">opendir</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-opendir" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to recursively add any file it can find in this
directory and down the file system tree.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-lockfile">
<code class="descname">lockfile</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-lockfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio defaults to not locking any files before it does
IO to them. If a file or file descriptor is shared, fio
can serialize IO to that file to make the end result
consistent. This is usual for emulating real workloads that
share files. The lock modes are:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">none</span></code></dt>
<dd>No locking. The default.</dd>
<dt><code class="docutils literal"><span class="pre">exclusive</span></code></dt>
<dd>Only one thread/process may do IO,
excluding all others.</dd>
<dt><code class="docutils literal"><span class="pre">readwrite</span></code></dt>
<dd>Read-write locking on the file. Many
readers may access the file at the
same time, but writes get exclusive
access.</dd>
</dl>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-readwrite">
<code class="descname">readwrite</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-readwrite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rw">
<code class="descname">rw</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-rw" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of io pattern. Accepted values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">read</span></code></dt>
<dd>Sequential reads</dd>
<dt><code class="docutils literal"><span class="pre">write</span></code></dt>
<dd>Sequential writes</dd>
<dt><code class="docutils literal"><span class="pre">randwrite</span></code></dt>
<dd>Random writes</dd>
<dt><code class="docutils literal"><span class="pre">randread</span></code></dt>
<dd>Random reads</dd>
<dt><code class="docutils literal"><span class="pre">rw,readwrite</span></code></dt>
<dd>Sequential mixed reads and writes</dd>
<dt><code class="docutils literal"><span class="pre">randrw</span></code></dt>
<dd>Random mixed reads and writes</dd>
<dt><code class="docutils literal"><span class="pre">trimwrite</span></code></dt>
<dd>Mixed trims and writes. Blocks will be
trimmed first, then written to.</dd>
</dl>
</div></blockquote>
<p>Fio defaults to read if the option is not specified.
For the mixed io types, the default is to split them 50/50.
For certain types of io the result may still be skewed a bit,
since the speed may be different. It is possible to specify
a number of IO&#8217;s to do before getting a new offset, this is
done by appending a &#8216;:&lt;nr&gt;&#8217; to the end of the string given.
For a random read, it would look like &#8216;rw=randread:8&#8217; for
passing in an offset modifier with a value of 8. If the
suffix is used with a sequential IO pattern, then the value
specified will be added to the generated offset for each IO.
For instance, using rw=write:4k will skip 4k for every
write. It turns sequential IO into sequential IO with holes.
See the <a class="reference internal" href="#cmdoption-arg-rw_sequencer"><code class="xref std std-option docutils literal"><span class="pre">rw_sequencer</span></code></a> option.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rw_sequencer">
<code class="descname">rw_sequencer</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-rw_sequencer" title="Permalink to this definition">¶</a></dt>
<dd><p>If an offset modifier is given by appending a number to
the rw=&lt;str&gt; line, then this option controls how that
number modifies the IO offset being generated. Accepted
values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sequential</span></code></dt>
<dd>Generate sequential offset</dd>
<dt><code class="docutils literal"><span class="pre">identical</span></code></dt>
<dd>Generate the same offset</dd>
</dl>
</div></blockquote>
<p>&#8216;sequential&#8217; is only useful for random IO, where fio would
normally generate a new random offset for every IO. If you
append eg 8 to randread, you would get a new random offset for
every 8 IO&#8217;s. The result would be a seek for only every 8
IO&#8217;s, instead of for every IO. Use rw=randread:8 to specify
that. As sequential IO is already sequential, setting
&#8216;sequential&#8217; for that would not result in any differences.
&#8216;identical&#8217; behaves in a similar fashion, except it sends
the same offset 8 number of times before generating a new
offset.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-kb_base">
<code class="descname">kb_base</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-kb_base" title="Permalink to this definition">¶</a></dt>
<dd><p>The base unit for a kilobyte. The defacto base is 2^10, 1024.
Storage manufacturers like to use 10^3 or 1000 as a base
ten unit instead, for obvious reasons. Allow values are
1024 or 1000, with 1024 being the default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unified_rw_reporting">
<code class="descname">unified_rw_reporting</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unified_rw_reporting" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio normally reports statistics on a per
data direction basis, meaning that read, write, and trim are
accounted and reported separately. If this option is set,
the fio will sum the results and report them as &#8220;mixed&#8221;
instead.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-randrepeat">
<code class="descname">randrepeat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-randrepeat" title="Permalink to this definition">¶</a></dt>
<dd><p>For random IO workloads, seed the generator in a predictable
way so that results are repeatable across repetitions.
Defaults to true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-randseed">
<code class="descname">randseed</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-randseed" title="Permalink to this definition">¶</a></dt>
<dd><p>Seed the random number generators based on this seed value, to
be able to control what sequence of output is being generated.
If not set, the random sequence depends on the randrepeat
setting.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fallocate">
<code class="descname">fallocate</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-fallocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether pre-allocation is performed when laying down files.
Accepted values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">none</span></code></dt>
<dd>Do not pre-allocate space</dd>
<dt><code class="docutils literal"><span class="pre">posix</span></code></dt>
<dd>Pre-allocate via posix_fallocate()</dd>
<dt><code class="docutils literal"><span class="pre">keep</span></code></dt>
<dd>Pre-allocate via fallocate() with
FALLOC_FL_KEEP_SIZE set</dd>
<dt><code class="docutils literal"><span class="pre">0</span></code></dt>
<dd>Backward-compatible alias for &#8216;none&#8217;</dd>
<dt><code class="docutils literal"><span class="pre">1</span></code></dt>
<dd>Backward-compatible alias for &#8216;posix&#8217;</dd>
</dl>
</div></blockquote>
<p>May not be available on all supported platforms. &#8216;keep&#8217; is only
available on Linux.If using ZFS on Solaris this must be set to
&#8216;none&#8217; because ZFS doesn&#8217;t support it. Default: &#8216;posix&#8217;.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fadvise_hint">
<code class="descname">fadvise_hint</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-fadvise_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, fio will use fadvise() to advise the kernel
on what IO patterns it is likely to issue. Sometimes you
want to test specific IO patterns without telling the
kernel about it, in which case you can disable this option.
The following options are supported:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sequential</span></code></dt>
<dd>Use FADV_SEQUENTIAL</dd>
<dt><code class="docutils literal"><span class="pre">random</span></code></dt>
<dd>Use FADV_RANDOM</dd>
<dt><code class="docutils literal"><span class="pre">1</span></code></dt>
<dd>Backwards-compatible hint for basing
the hint on the fio workload. Will use
FADV_SEQUENTIAL for a sequential
workload, and FADV_RANDOM for a random
workload.</dd>
<dt><code class="docutils literal"><span class="pre">0</span></code></dt>
<dd>Backwards-compatible setting for not
issing a fadvise hint.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fadvise_stream">
<code class="descname">fadvise_stream</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-fadvise_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify the kernel what write stream ID to place these
writes under. Only supported on Linux. Note, this option
may change going forward.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-size">
<code class="descname">size</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-size" title="Permalink to this definition">¶</a></dt>
<dd><p>The total size of file io for this job. Fio will run until
this many bytes has been transferred, unless runtime is
limited by other options (such as &#8216;runtime&#8217;, for instance,
or increased/decreased by &#8216;io_size&#8217;). Unless specific nrfiles
and filesize options are given, fio will divide this size
between the available files specified by the job. If not set,
fio will use the full size of the given files or devices.
If the files do not exist, size must be given. It is also
possible to give size as a percentage between 1 and 100. If
size=20% is given, fio will use 20% of the full size of the
given files or devices.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-io_size">
<code class="descname">io_size</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-io_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-io_limit">
<code class="descname">io_limit</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-io_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio operates within the region set by &#8216;size&#8217;, which
means that the &#8216;size&#8217; option sets both the region and size of
IO to be performed. Sometimes that is not what you want. With
this option, it is possible to define just the amount of IO
that fio should do. For instance, if &#8216;size&#8217; is set to 20G and
&#8216;io_size&#8217; is set to 5G, fio will perform IO within the first
20G but exit when 5G have been done. The opposite is also
possible - if &#8216;size&#8217; is set to 20G, and &#8216;io_size&#8217; is set to
40G, then fio will do 40G of IO within the 0..20G region.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-filesize">
<code class="descname">filesize</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-filesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Individual file sizes. May be a range, in which case fio
will select sizes for files at random within the given range
and limited to &#8216;size&#8217; in total (if that is given). If not
given, each created file is the same size.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-file_append">
<code class="descname">file_append</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-file_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform IO after the end of the file. Normally fio will
operate within the size of a file. If this option is set, then
fio will append to the file instead. This has identical
behavior to setting offset to the size of a file. This option
is ignored on non-regular files.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fill_device">
<code class="descname">fill_device</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-fill_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fill_fs">
<code class="descname">fill_fs</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-fill_fs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets size to something really large and waits for ENOSPC (no
space left on device) as the terminating condition. Only makes
sense with sequential write. For a read workload, the mount
point will be filled first then IO started on the result. This
option doesn&#8217;t make sense if operating on a raw device node,
since the size of that is already known by the file system.
Additionally, writing beyond end-of-device will not return
ENOSPC there.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blocksize">
<code class="descname">blocksize</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-blocksize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bs">
<code class="descname">bs</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-bs" title="Permalink to this definition">¶</a></dt>
<dd><p>The block size used for the io units. Defaults to 4k. Values
can be given for both read and writes. If a single int is
given, it will apply to both. If a second int is specified
after a comma, it will apply to writes only. In other words,
the format is either bs=read_and_write or bs=read,write,trim.
bs=4k,8k will thus use 4k blocks for reads, 8k blocks for
writes, and 8k for trims. You can terminate the list with
a trailing comma. bs=4k,8k, would use the default value for
trims.. If you only wish to set the write size, you
can do so by passing an empty read size - bs=,8k will set
8k for writes and leave the read default value.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blockalign">
<code class="descname">blockalign</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-blockalign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ba">
<code class="descname">ba</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-ba" title="Permalink to this definition">¶</a></dt>
<dd><p>At what boundary to align random IO offsets. Defaults to
the same as &#8216;blocksize&#8217; the minimum blocksize given.
Minimum alignment is typically 512b for using direct IO,
though it usually depends on the hardware block size. This
option is mutually exclusive with using a random map for
files, so it will turn off that option.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blocksize_range">
<code class="descname">blocksize_range</code><code class="descclassname">=irange</code><a class="headerlink" href="#cmdoption-arg-blocksize_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bsrange">
<code class="descname">bsrange</code><code class="descclassname">=irange</code><a class="headerlink" href="#cmdoption-arg-bsrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of giving a single block size, specify a range
and fio will mix the issued io block sizes. The issued
io unit will always be a multiple of the minimum value
given (also see <a class="reference internal" href="#cmdoption-arg-bs_unaligned"><code class="xref std std-option docutils literal"><span class="pre">bs_unaligned</span></code></a>). Applies to both reads and
writes, however a second range can be given after a comma.
See <a class="reference internal" href="#cmdoption-arg-bs"><code class="xref std std-option docutils literal"><span class="pre">bs</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bssplit">
<code class="descname">bssplit</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-bssplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes you want even finer grained control of the
block sizes issued, not just an even split between them.
This option allows you to weight various block sizes,
so that you are able to define a specific amount of
block sizes issued. The format for this option is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bssplit</span><span class="o">=</span><span class="n">blocksize</span><span class="o">/</span><span class="n">percentage</span><span class="p">:</span><span class="n">blocksize</span><span class="o">/</span><span class="n">percentage</span>
</pre></div>
</div>
<p>for as many block sizes as needed. So if you want to define
a workload that has 50% 64k blocks, 10% 4k blocks, and
40% 32k blocks, you would write:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bssplit</span><span class="o">=</span><span class="mi">4</span><span class="n">k</span><span class="o">/</span><span class="mi">10</span><span class="p">:</span><span class="mi">64</span><span class="n">k</span><span class="o">/</span><span class="mi">50</span><span class="p">:</span><span class="mi">32</span><span class="n">k</span><span class="o">/</span><span class="mi">40</span>
</pre></div>
</div>
<p>Ordering does not matter. If the percentage is left blank,
fio will fill in the remaining values evenly. So a bssplit
option like this one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bssplit</span><span class="o">=</span><span class="mi">4</span><span class="n">k</span><span class="o">/</span><span class="mi">50</span><span class="p">:</span><span class="mi">1</span><span class="n">k</span><span class="o">/</span><span class="p">:</span><span class="mi">32</span><span class="n">k</span><span class="o">/</span>
</pre></div>
</div>
<p>would have 50% 4k ios, and 25% 1k and 32k ios. The percentages
always add up to 100, if bssplit is given a range that adds
up to more, it will error out.</p>
<p>bssplit also supports giving separate splits to reads and
writes. The format is identical to what bs= accepts. You
have to separate the read and write parts with a comma. So
if you want a workload that has 50% 2k reads and 50% 4k reads,
while having 90% 4k writes and 10% 8k writes, you would
specify:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bssplit</span><span class="o">=</span><span class="mi">2</span><span class="n">k</span><span class="o">/</span><span class="mi">50</span><span class="p">:</span><span class="mi">4</span><span class="n">k</span><span class="o">/</span><span class="mi">50</span><span class="p">,</span><span class="mi">4</span><span class="n">k</span><span class="o">/</span><span class="mi">90</span><span class="p">,</span><span class="mi">8</span><span class="n">k</span><span class="o">/</span><span class="mi">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blocksize_unaligned">
<code class="descname">blocksize_unaligned</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-blocksize_unaligned" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bs_unaligned">
<code class="descname">bs_unaligned</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-bs_unaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>If this option is given, any byte size value within bsrange
may be used as a block range. This typically wont work with
direct IO, as that normally requires sector alignment.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bs_is_seq_rand">
<code class="descname">bs_is_seq_rand</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-bs_is_seq_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>If this option is set, fio will use the normal read,write
blocksize settings as sequential,random instead. Any random
read or write will use the WRITE blocksize settings, and any
sequential read or write will use the READ blocksize setting.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-zero_buffers">
<code class="descname">zero_buffers</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-zero_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>If this option is given, fio will init the IO buffers to
all zeroes. The default is to fill them with random data.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-refill_buffers">
<code class="descname">refill_buffers</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-refill_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>If this option is given, fio will refill the IO buffers
on every submit. The default is to only fill it at init
time and reuse that data. Only makes sense if zero_buffers
isn&#8217;t specified, naturally. If data verification is enabled,
refill_buffers is also automatically enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-scramble_buffers">
<code class="descname">scramble_buffers</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-scramble_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>If refill_buffers is too costly and the target is
using data deduplication, then setting this option will
slightly modify the IO buffer contents to defeat normal
de-dupe attempts. This is not enough to defeat more clever
block compression attempts, but it will stop naive dedupe of
blocks. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffer_compress_percentage">
<code class="descname">buffer_compress_percentage</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-buffer_compress_percentage" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is set, then fio will attempt to
provide IO buffer content (on WRITEs) that compress to
the specified level. Fio does this by providing a mix of
random data and a fixed pattern. The fixed pattern is either
zeroes, or the pattern specified by buffer_pattern. If the
pattern option is used, it might skew the compression ratio
slightly. Note that this is per block size unit, for file/disk
wide compression level that matches this setting, you&#8217;ll also
want to set refill_buffers.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffer_compress_chunk">
<code class="descname">buffer_compress_chunk</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-buffer_compress_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#cmdoption-arg-buffer_compress_percentage"><code class="xref std std-option docutils literal"><span class="pre">buffer_compress_percentage</span></code></a>. This
setting allows fio to manage how big the ranges of random
data and zeroed data is. Without this set, fio will
provide buffer_compress_percentage of blocksize random
data, followed by the remaining zeroed. With this set
to some chunk size smaller than the block size, fio can
alternate random and zeroed data throughout the IO
buffer.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffer_pattern">
<code class="descname">buffer_pattern</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-buffer_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will fill the io buffers with this
pattern. If not set, the contents of io buffers is defined by
the other options related to buffer contents. The setting can
be any pattern of bytes, and can be prefixed with 0x for hex
values. It may also be a string, where the string must then
be wrapped with &#8220;&#8221;, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">buffer_pattern</span><span class="o">=</span><span class="s2">&quot;abcd&quot;</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">buffer_pattern</span><span class="o">=-</span><span class="mi">12</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">buffer_pattern</span><span class="o">=</span><span class="mh">0xdeadface</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Also you can combine everything together in any order::</dt>
<dd>buffer_pattern=0xdeadface&#8221;abcd&#8221;-12</dd>
</dl>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-dedupe_percentage">
<code class="descname">dedupe_percentage</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-dedupe_percentage" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will generate this percentage of
identical buffers when writing. These buffers will be
naturally dedupable. The contents of the buffers depend on
what other buffer compression settings have been set. It&#8217;s
possible to have the individual buffers either fully
compressible, or not at all. This option only controls the
distribution of unique buffers.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-nrfiles">
<code class="descname">nrfiles</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-nrfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of files to use for this job. Defaults to 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-openfiles">
<code class="descname">openfiles</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-openfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of files to keep open at the same time. Defaults to
the same as nrfiles, can be set smaller to limit the number
simultaneous opens.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-file_service_type">
<code class="descname">file_service_type</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-file_service_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how fio decides which file from a job to
service next. The following types are defined:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">random</span></code></dt>
<dd>Just choose a file at random.</dd>
<dt><code class="docutils literal"><span class="pre">roundrobin</span></code></dt>
<dd>Round robin over open files. This
is the default.</dd>
<dt><code class="docutils literal"><span class="pre">sequential</span></code></dt>
<dd>Finish one file before moving on to
the next. Multiple files can still be
open depending on &#8216;openfiles&#8217;.</dd>
<dt><code class="docutils literal"><span class="pre">zipf</span></code></dt>
<dd>Use a zipfian distribution to decide what file
to access.</dd>
<dt><code class="docutils literal"><span class="pre">pareto</span></code></dt>
<dd>Use a pareto distribution to decide what file
to access.</dd>
<dt><code class="docutils literal"><span class="pre">gauss</span></code></dt>
<dd>Use a gaussian (normal) distribution to decide
what file to access.</dd>
</dl>
</div></blockquote>
<p>For random, roundrobin, and sequential, a postfix can be
appended to tell fio how many I/Os to issue before switching
to a new file. For example, specifying
&#8216;file_service_type=random:8&#8217; would cause fio to issue 8 I/Os
before selecting a new file at random. For the non-uniform
distributions, a floating point postfix can be given to
influence how the distribution is skewed. See
<a class="reference internal" href="#cmdoption-arg-random_distribution"><code class="xref std std-option docutils literal"><span class="pre">random_distribution</span></code></a> for a description of how that would work.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ioengine">
<code class="descname">ioengine</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-ioengine" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how the job issues io to the file. The following
types are defined:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sync</span></code></dt>
<dd>Basic <cite>read(2)</cite> or <cite>write(2)</cite> io. <cite>lseek(2)</cite> is
used to position the io location.</dd>
<dt><code class="docutils literal"><span class="pre">psync</span></code></dt>
<dd>Basic <cite>pread(2)</cite> or <cite>pwrite(2)</cite> io. Default on all
supported operating systems except for Windows.</dd>
<dt><code class="docutils literal"><span class="pre">vsync</span></code></dt>
<dd>Basic <cite>readv(2)</cite> or <cite>writev(2)</cite> IO.</dd>
<dt><code class="docutils literal"><span class="pre">pvsync</span></code></dt>
<dd>Basic <cite>preadv(2)</cite> or <cite>pwritev(2)</cite> IO.</dd>
<dt><code class="docutils literal"><span class="pre">pvsync2</span></code></dt>
<dd>Basic <cite>preadv2(2)</cite> or <cite>pwritev2(2)</cite> IO.</dd>
<dt><code class="docutils literal"><span class="pre">libaio</span></code></dt>
<dd>Linux native asynchronous io. Note that Linux
may only support queued behaviour with
non-buffered IO (set direct=1 or buffered=0).
This engine defines engine specific options.</dd>
<dt><code class="docutils literal"><span class="pre">posixaio</span></code></dt>
<dd>glibc posix asynchronous io.</dd>
<dt><code class="docutils literal"><span class="pre">solarisaio</span></code></dt>
<dd>Solaris native asynchronous io.</dd>
<dt><code class="docutils literal"><span class="pre">windowsaio</span></code></dt>
<dd>Windows native asynchronous io.
Default on Windows.</dd>
<dt><code class="docutils literal"><span class="pre">mmap</span></code></dt>
<dd>File is memory mapped and data copied
to/from using memcpy(3).</dd>
<dt><code class="docutils literal"><span class="pre">splice</span></code></dt>
<dd><cite>splice(2)</cite> is used to transfer the data and
<cite>vmsplice(2)</cite> to transfer data from user
space to the kernel.</dd>
<dt><code class="docutils literal"><span class="pre">sg</span></code></dt>
<dd>SCSI generic sg v3 io. May either be
synchronous using the SG_IO ioctl, or if
the target is an sg character device
we use <cite>read(2)</cite> and <cite>write(2)</cite> for asynchronous
io.</dd>
<dt><code class="docutils literal"><span class="pre">null</span></code></dt>
<dd>Doesn&#8217;t transfer any data, just pretends
to. This is mainly used to exercise fio
itself and for debugging/testing purposes.</dd>
<dt><code class="docutils literal"><span class="pre">net</span></code></dt>
<dd>Transfer over the network to given <code class="docutils literal"><span class="pre">host:port</span></code>.
Depending on the <a class="reference internal" href="#cmdoption-arg-protocol"><code class="xref std std-option docutils literal"><span class="pre">protocol</span></code></a> used, the <a class="reference internal" href="#cmdoption-arg-hostname"><code class="xref std std-option docutils literal"><span class="pre">hostname</span></code></a>,
<a class="reference internal" href="#cmdoption-arg-port"><code class="xref std std-option docutils literal"><span class="pre">port</span></code></a>, <a class="reference internal" href="#cmdoption-arg-listen"><code class="xref std std-option docutils literal"><span class="pre">listen</span></code></a> and <a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a> options are used to
specify what sort of connection to make, while
the <a class="reference internal" href="#cmdoption-arg-protocol"><code class="xref std std-option docutils literal"><span class="pre">protocol</span></code></a> option determines which protocol
will be used.
This engine defines engine specific options.</dd>
<dt><code class="docutils literal"><span class="pre">netsplice</span></code></dt>
<dd>Like net, but uses splice/vmsplice to
map data and send/receive.
This engine defines engine specific options.</dd>
<dt><code class="docutils literal"><span class="pre">cpuio</span></code></dt>
<dd>Doesn&#8217;t transfer any data, but burns CPU
cycles according to the <a class="reference internal" href="#cmdoption-arg-cpuload"><code class="xref std std-option docutils literal"><span class="pre">cpuload</span></code></a> and
<a class="reference internal" href="#cmdoption-arg-cpuchunks"><code class="xref std std-option docutils literal"><span class="pre">cpuchunks</span></code></a> options. Setting <a class="reference internal" href="#cmdoption-arg-cpuload"><code class="xref std std-option docutils literal"><span class="pre">cpuload</span></code></a> =85
will cause that job to do nothing but burn
85% of the CPU. In case of SMP machines,
use <a class="reference internal" href="#cmdoption-arg-numjobs"><code class="xref std std-option docutils literal"><span class="pre">numjobs</span></code></a> =&lt;no_of_cpu&gt; to get desired CPU
usage, as the cpuload only loads a single
CPU at the desired rate. A job never finishes
unless there is at least one non-cpuio job.</dd>
<dt><code class="docutils literal"><span class="pre">guasi</span></code></dt>
<dd><p class="first">The GUASI IO engine is the Generic Userspace
Asyncronous Syscall Interface approach
to async IO. See</p>
<p><a class="reference external" href="http://www.xmailserver.org/guasi-lib.html">http://www.xmailserver.org/guasi-lib.html</a></p>
<p class="last">for more info on GUASI.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">rdma</span></code></dt>
<dd>The RDMA I/O engine  supports  both  RDMA
memory semantics (RDMA_WRITE/RDMA_READ) and
channel semantics (Send/Recv) for the
InfiniBand, RoCE and iWARP protocols.</dd>
<dt><code class="docutils literal"><span class="pre">falloc</span></code></dt>
<dd>IO engine that does regular fallocate to
simulate data transfer as fio ioengine.
DDIR_READ  does fallocate(,mode = keep_size,)
DDIR_WRITE does fallocate(,mode = 0)
DDIR_TRIM  does fallocate(,mode = punch_hole)</dd>
<dt><code class="docutils literal"><span class="pre">e4defrag</span></code></dt>
<dd>IO engine that does regular EXT4_IOC_MOVE_EXT
ioctls to simulate defragment activity in
request to DDIR_WRITE event</dd>
<dt><code class="docutils literal"><span class="pre">rbd</span></code></dt>
<dd>IO engine supporting direct access to Ceph
Rados Block Devices (RBD) via librbd without
the need to use the kernel rbd driver. This
ioengine defines engine specific options.</dd>
<dt><code class="docutils literal"><span class="pre">gfapi</span></code></dt>
<dd>Using Glusterfs libgfapi sync interface to
direct access to Glusterfs volumes without
options.</dd>
<dt><code class="docutils literal"><span class="pre">gfapi_async</span></code></dt>
<dd>Using Glusterfs libgfapi async interface
to direct access to Glusterfs volumes without
having to go through FUSE. This ioengine
defines engine specific options.</dd>
<dt><code class="docutils literal"><span class="pre">libhdfs</span></code></dt>
<dd>Read and write through Hadoop (HDFS).
This engine interprets offsets a little
differently. In HDFS, files once created
cannot be modified. So random writes are not
possible. To imitate this, libhdfs engine
creates bunch of small files, and engine will
pick a file out of those files based on the
offset generated by fio backend. Each jobs uses
it&#8217;s own connection to HDFS.</dd>
<dt><code class="docutils literal"><span class="pre">mtd</span></code></dt>
<dd>Read, write and erase an MTD character device
(e.g., /dev/mtd0). Discards are treated as
erases. Depending on the underlying device
type, the I/O may have to go in a certain
pattern, e.g., on NAND, writing sequentially
to erase blocks and discarding before
overwriting. The writetrim mode works well
for this constraint.</dd>
<dt><code class="docutils literal"><span class="pre">pmemblk</span></code></dt>
<dd>Read and write through the NVML libpmemblk
interface.</dd>
<dt><code class="docutils literal"><span class="pre">dev-dax</span></code></dt>
<dd>Read and write through a DAX device exposed
from persistent memory.</dd>
<dt><code class="docutils literal"><span class="pre">external</span></code></dt>
<dd>Prefix to specify loading an external
IO engine object file. Append the engine
filename, eg <code class="docutils literal"><span class="pre">ioengine=external:/tmp/foo.o</span></code>
to load ioengine <code class="docutils literal"><span class="pre">foo.o</span></code> in <code class="docutils literal"><span class="pre">/tmp</span></code>.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth">
<code class="descname">iodepth</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines how many io units to keep in flight against
the file. The default is 1 for each file defined in this
job, can be overridden with a larger value for higher
concurrency. Note that increasing iodepth beyond 1 will not
affect synchronous ioengines (except for small degress when
verify_async is in use). Even async engines may impose OS
restrictions causing the desired depth not to be achieved.
This may happen on Linux when using libaio and not setting
direct=1, since buffered IO is not async on that OS. Keep an
eye on the IO depth distribution in the fio output to verify
that the achieved depth is as expected. Default: 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_submit">
<code class="descname">iodepth_batch_submit</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_submit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch">
<code class="descname">iodepth_batch</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines how many pieces of IO to submit at once.
It defaults to 1 which means that we submit each IO
as soon as it is available, but can be raised to submit
bigger batches of IO at the time. If it is set to 0 the iodepth
value will be used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_complete_min">
<code class="descname">iodepth_batch_complete_min</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_complete_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_complete">
<code class="descname">iodepth_batch_complete</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines how many pieces of IO to retrieve
at once. It defaults to 1 which means that we&#8217;ll ask
for a minimum of 1 IO in the retrieval process from
the kernel. The IO retrieval will go on until we
hit the limit set by <a class="reference internal" href="#cmdoption-arg-iodepth_low"><code class="xref std std-option docutils literal"><span class="pre">iodepth_low</span></code></a>. If this variable is
set to 0, then fio will always check for completed
events before queuing more IO. This helps reduce
IO latency, at the cost of more retrieval system calls.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_complete_max">
<code class="descname">iodepth_batch_complete_max</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_complete_max" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines maximum pieces of IO to
retrieve at once. This variable should be used along with
iodepth_batch_complete_min=int variable, specifying the range
of min and max amount of IO which should be retrieved. By default
it is equal to iodepth_batch_complete_min value.</p>
<p>Example #1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">iodepth_batch_complete_min</span><span class="o">=</span><span class="mi">1</span>
<span class="n">iodepth_batch_complete_max</span><span class="o">=&lt;</span><span class="n">iodepth</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>which means that we will retrieve at least 1 IO and up to the
whole submitted queue depth. If none of IO has been completed
yet, we will wait.</p>
<p>Example #2:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">iodepth_batch_complete_min</span><span class="o">=</span><span class="mi">0</span>
<span class="n">iodepth_batch_complete_max</span><span class="o">=&lt;</span><span class="n">iodepth</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>which means that we can retrieve up to the whole submitted
queue depth, but if none of IO has been completed yet, we will
NOT wait and immediately exit the system call. In this example
we simply do polling.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_low">
<code class="descname">iodepth_low</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_low" title="Permalink to this definition">¶</a></dt>
<dd><p>The low water mark indicating when to start filling
the queue again. Defaults to the same as iodepth, meaning
that fio will attempt to keep the queue full at all times.
If iodepth is set to eg 16 and iodepth_low is set to 4, then
after fio has filled the queue of 16 requests, it will let
the depth drain down to 4 before starting to fill it again.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-io_submit_mode">
<code class="descname">io_submit_mode</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-io_submit_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls how fio submits the IO to
the IO engine. The default is &#8216;inline&#8217;, which means that the
fio job threads submit and reap IO directly. If set to
&#8216;offload&#8217;, the job threads will offload IO submission to a
dedicated pool of IO threads. This requires some coordination
and thus has a bit of extra overhead, especially for lower
queue depth IO where it can increase latencies. The benefit
is that fio can manage submission rates independently of
the device completion rates. This avoids skewed latency
reporting if IO gets back up on the device side (the
coordinated omission problem).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-direct">
<code class="descname">direct</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-direct" title="Permalink to this definition">¶</a></dt>
<dd><p>If value is true, use non-buffered io. This is usually
O_DIRECT. Note that ZFS on Solaris doesn&#8217;t support direct io.
On Windows the synchronous ioengines don&#8217;t support direct io.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-atomic">
<code class="descname">atomic</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>If value is true, attempt to use atomic direct IO. Atomic
writes are guaranteed to be stable once acknowledged by
the operating system. Only Linux supports O_ATOMIC right
now.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffered">
<code class="descname">buffered</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-buffered" title="Permalink to this definition">¶</a></dt>
<dd><p>If value is true, use buffered io. This is the opposite
of the &#8216;direct&#8217; option. Defaults to true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-offset">
<code class="descname">offset</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Start io at the given offset in the file. The data before
the given offset will not be touched. This effectively
caps the file size at real_size - offset.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-offset_increment">
<code class="descname">offset_increment</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-offset_increment" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is provided, then the real offset becomes
offset + offset_increment * thread_number, where the thread
number is a counter that starts at 0 and is incremented for
each sub-job (i.e. when numjobs option is specified). This
option is useful if there are several jobs which are intended
to operate on a file in parallel disjoint segments, with
even spacing between the starting points.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-number_ios">
<code class="descname">number_ios</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-number_ios" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio will normally perform IOs until it has exhausted the size
of the region set by size=, or if it exhaust the allocated
time (or hits an error condition). With this setting, the
range/size can be set independently of the number of IOs to
perform. When fio reaches this number, it will exit normally
and report status. Note that this does not extend the amount
of IO that will be done, it will only stop fio if this
condition is met before other end-of-job criteria.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fsync">
<code class="descname">fsync</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>If writing to a file, issue a sync of the dirty data
for every number of blocks given. For example, if you give
32 as a parameter, fio will sync the file for every 32
writes issued. If fio is using non-buffered io, we may
not sync the file. The exception is the sg io engine, which
synchronizes the disk cache anyway.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fdatasync">
<code class="descname">fdatasync</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-fdatasync" title="Permalink to this definition">¶</a></dt>
<dd><p>Like fsync= but uses <cite>fdatasync()</cite> to only sync data and not
metadata blocks.
In FreeBSD and Windows there is no <cite>fdatasync()</cite>, this falls back
to using <cite>fsync()</cite></p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-sync_file_range">
<code class="descname">sync_file_range</code><code class="descclassname">=str:val</code><a class="headerlink" href="#cmdoption-arg-sync_file_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <cite>sync_file_range()</cite> for every &#8216;val&#8217; number of
write operations. Fio will track range of writes that
have happened since the last <cite>sync_file_range()</cite> call. &#8216;str&#8217;
can currently be one or more of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">wait_before</span> <span class="n">SYNC_FILE_RANGE_WAIT_BEFORE</span>
<span class="n">write</span>       <span class="n">SYNC_FILE_RANGE_WRITE</span>
<span class="n">wait_after</span>  <span class="n">SYNC_FILE_RANGE_WAIT_AFTER</span>
</pre></div>
</div>
<p>So if you do <code class="docutils literal"><span class="pre">sync_file_range=wait_before,write:8</span></code>, fio would
use <code class="docutils literal"><span class="pre">SYNC_FILE_RANGE_WAIT_BEFORE</span> <span class="pre">|</span> <span class="pre">SYNC_FILE_RANGE_WRITE</span></code> for
every 8 writes. Also see the <cite>sync_file_range(2)</cite> man page.
This option is Linux specific.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-overwrite">
<code class="descname">overwrite</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-overwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, writes to a file will always overwrite existing
data. If the file doesn&#8217;t already exist, it will be
created before the write phase begins. If the file exists
and is large enough for the specified write phase, nothing
will be done.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-end_fsync">
<code class="descname">end_fsync</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-end_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fsync file contents when a write stage has completed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fsync_on_close">
<code class="descname">fsync_on_close</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-fsync_on_close" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio will <cite>fsync()</cite> a dirty file on close.
This differs from end_fsync in that it will happen on every
file close, not just at the end of the job.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rwmixread">
<code class="descname">rwmixread</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rwmixread" title="Permalink to this definition">¶</a></dt>
<dd><p>How large a percentage of the mix should be reads.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rwmixwrite">
<code class="descname">rwmixwrite</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rwmixwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>How large a percentage of the mix should be writes. If both
rwmixread and rwmixwrite is given and the values do not add
up to 100%, the latter of the two will be used to override
the first. This may interfere with a given rate setting,
if fio is asked to limit reads or writes to a certain rate.
If that is the case, then the distribution may be skewed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-random_distribution">
<code class="descname">random_distribution</code><code class="descclassname">=str:float</code><a class="headerlink" href="#cmdoption-arg-random_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, fio will use a completely uniform
random distribution when asked to perform random IO. Sometimes
it is useful to skew the distribution in specific ways,
ensuring that some parts of the data is more hot than others.
fio includes the following distribution models:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">random</span></code></dt>
<dd>Uniform random distribution</dd>
<dt><code class="docutils literal"><span class="pre">zipf</span></code></dt>
<dd>Zipf distribution</dd>
<dt><code class="docutils literal"><span class="pre">pareto</span></code></dt>
<dd>Pareto distribution</dd>
<dt><code class="docutils literal"><span class="pre">gauss</span></code></dt>
<dd>Normal (gaussian) distribution</dd>
<dt><code class="docutils literal"><span class="pre">zoned</span></code></dt>
<dd>Zoned random distribution</dd>
</dl>
<p>When using a zipf or pareto distribution, an input value
is also needed to define the access pattern. For zipf, this
is the zipf theta. For pareto, it&#8217;s the pareto power. Fio
includes a test program, genzipf, that can be used visualize
what the given input values will yield in terms of hit rates.
If you wanted to use zipf with a theta of 1.2, you would use
random_distribution=zipf:1.2 as the option. If a non-uniform
model is used, fio will disable use of the random map. For
the gauss distribution, a normal deviation is supplied as
a value between 0 and 100.</p>
<p>For a zoned distribution, fio supports specifying percentages
of IO access that should fall within what range of the file or
device. For example, given a criteria of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">60</span><span class="o">%</span> <span class="n">of</span> <span class="n">accesses</span> <span class="n">should</span> <span class="n">be</span> <span class="n">to</span> <span class="n">the</span> <span class="n">first</span> <span class="mi">10</span><span class="o">%</span>
<span class="mi">30</span><span class="o">%</span> <span class="n">of</span> <span class="n">accesses</span> <span class="n">should</span> <span class="n">be</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">next</span> <span class="mi">20</span><span class="o">%</span>
<span class="mi">8</span><span class="o">%</span> <span class="n">of</span> <span class="n">accesses</span> <span class="n">should</span> <span class="n">be</span> <span class="n">to</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">next</span> <span class="mi">30</span><span class="o">%</span>
<span class="mi">2</span><span class="o">%</span> <span class="n">of</span> <span class="n">accesses</span> <span class="n">should</span> <span class="n">be</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">next</span> <span class="mi">40</span><span class="o">%</span>
</pre></div>
</div>
<p>we can define that through zoning of the random accesses. For
the above example, the user would do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">random_distribution</span><span class="o">=</span><span class="n">zoned</span><span class="p">:</span><span class="mi">60</span><span class="o">/</span><span class="mi">10</span><span class="p">:</span><span class="mi">30</span><span class="o">/</span><span class="mi">20</span><span class="p">:</span><span class="mi">8</span><span class="o">/</span><span class="mi">30</span><span class="p">:</span><span class="mi">2</span><span class="o">/</span><span class="mi">40</span>
</pre></div>
</div>
<p>similarly to how bssplit works for setting ranges and
percentages of block sizes. Like bssplit, it&#8217;s possible to
specify separate zones for reads, writes, and trims. If just
one set is given, it&#8217;ll apply to all of them.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-percentage_random">
<code class="descname">percentage_random</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-percentage_random" title="Permalink to this definition">¶</a></dt>
<dd><p>For a random workload, set how big a percentage should
be random. This defaults to 100%, in which case the workload
is fully random. It can be set from anywhere from 0 to 100.
Setting it to 0 would make the workload fully sequential. Any
setting in between will result in a random mix of sequential
and random IO, at the given percentages. It is possible to
set different values for reads, writes, and trim. To do so,
simply use a comma separated list. See <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-norandommap">
<code class="descname">norandommap</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-norandommap" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will cover every block of the file when doing
random IO. If this option is given, fio will just get a
new random offset without looking at past io history. This
means that some blocks may not be read or written, and that
some blocks may be read/written more than once. If this option
is used with <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> and multiple blocksizes (via <a class="reference internal" href="#cmdoption-arg-bsrange"><code class="xref std std-option docutils literal"><span class="pre">bsrange</span></code></a>),
only intact blocks are verified, i.e., partially-overwritten
blocks are ignored.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-softrandommap">
<code class="descname">softrandommap</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-softrandommap" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#cmdoption-arg-norandommap"><code class="xref std std-option docutils literal"><span class="pre">norandommap</span></code></a>. If fio runs with the random block map
enabled and it fails to allocate the map, if this option is
set it will continue without a random block map. As coverage
will not be as complete as with random maps, this option is
disabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-random_generator">
<code class="descname">random_generator</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-random_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio supports the following engines for generating
IO offsets for random IO:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tausworthe</span></code>   - Strong 2^88 cycle random number generator</li>
<li><code class="docutils literal"><span class="pre">lfsr</span></code>         - Linear feedback shift register generator</li>
<li><code class="docutils literal"><span class="pre">tausworthe64</span></code> - Strong 64-bit 2^258 cycle random number generator</li>
</ul>
<p>Tausworthe is a strong random number generator, but it
requires tracking on the side if we want to ensure that
blocks are only read or written once. LFSR guarantees
that we never generate the same offset twice, and it&#8217;s
also less computationally expensive. It&#8217;s not a true
random generator, however, though for IO purposes it&#8217;s
typically good enough. LFSR only works with single
block sizes, not with workloads that use multiple block
sizes. If used with such a workload, fio may read or write
some blocks multiple times. The default value is tausworthe,
unless the required space exceeds 2^32 blocks. If it does,
then tausworthe64 is selected automatically.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-nice">
<code class="descname">nice</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-nice" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the job with the given nice value. See man <cite>nice(2)</cite>.</p>
<p>On Windows, values less than -15 set the process class to &#8220;High&#8221;;
-1 through -15 set &#8220;Above Normal&#8221;; 1 through 15 &#8220;Below Normal&#8221;;
and above 15 &#8220;Idle&#8221; priority class.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-prio">
<code class="descname">prio</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-prio" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the io priority value of this job. Linux limits us to
a positive value between 0 and 7, with 0 being the highest.
See man <cite>ionice(1)</cite>. Refer to an appropriate manpage for
other operating systems since meaning of priority may differ.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-prioclass">
<code class="descname">prioclass</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-prioclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the io priority class. See man <cite>ionice(1)</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-thinktime">
<code class="descname">thinktime</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-thinktime" title="Permalink to this definition">¶</a></dt>
<dd><p>Stall the job x microseconds after an io has completed before
issuing the next. May be used to simulate processing being
done by an application. See <a class="reference internal" href="#cmdoption-arg-thinktime_blocks"><code class="xref std std-option docutils literal"><span class="pre">thinktime_blocks</span></code></a> and
<a class="reference internal" href="#cmdoption-arg-thinktime_spin"><code class="xref std std-option docutils literal"><span class="pre">thinktime_spin</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-thinktime_spin">
<code class="descname">thinktime_spin</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-thinktime_spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Only valid if thinktime is set - pretend to spend CPU time
doing something with the data received, before falling back
to sleeping for the rest of the period specified by
thinktime.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-thinktime_blocks">
<code class="descname">thinktime_blocks</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-thinktime_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Only valid if thinktime is set - control how many blocks
to issue, before waiting &#8216;thinktime&#8217; usecs. If not set,
defaults to 1 which will make fio wait &#8216;thinktime&#8217; usecs
after every block. This effectively makes any queue depth
setting redundant, since no more than 1 IO will be queued
before we have to complete it and do our thinktime. In
other words, this setting effectively caps the queue depth
if the latter is larger.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate">
<code class="descname">rate</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Cap the bandwidth used by this job. The number is in bytes/sec,
the normal suffix rules apply. You can use rate=500k to limit
reads and writes to 500k each, or you can specify read and
writes separately. Using rate=1m,500k would limit reads to
1MB/sec and writes to 500KB/sec. Capping only reads or
writes can be done with rate=,500k or rate=500k,. The former
will only limit writes (to 500KB/sec), the latter will only
limit reads.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_min">
<code class="descname">rate_min</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rate_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to do whatever it can to maintain at least this
bandwidth. Failing to meet this requirement, will cause
the job to exit. The same format as rate is used for
read vs write separation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_iops">
<code class="descname">rate_iops</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rate_iops" title="Permalink to this definition">¶</a></dt>
<dd><p>Cap the bandwidth to this number of IOPS. Basically the same
as rate, just specified independently of bandwidth. If the
job is given a block size range instead of a fixed value,
the smallest block size is used as the metric. The same format
as rate is used for read vs write separation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_iops_min">
<code class="descname">rate_iops_min</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rate_iops_min" title="Permalink to this definition">¶</a></dt>
<dd><p>If fio doesn&#8217;t meet this rate of IO, it will cause
the job to exit. The same format as rate is used for read vs
write separation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_process">
<code class="descname">rate_process</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-rate_process" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls how fio manages rated IO
submissions. The default is &#8216;linear&#8217;, which submits IO in a
linear fashion with fixed delays between IOs that gets
adjusted based on IO completion rates. If this is set to
&#8216;poisson&#8217;, fio will submit IO based on a more real world
random request flow, known as the Poisson process
(<a class="reference external" href="https://en.wikipedia.org/wiki/Poisson_process">https://en.wikipedia.org/wiki/Poisson_process</a>). The lambda
will be 10^6 / IOPS for the given workload.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-latency_target">
<code class="descname">latency_target</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-latency_target" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will attempt to find the max performance
point that the given workload will run at while maintaining a
latency below this target. The values is given in microseconds.
See <a class="reference internal" href="#cmdoption-arg-latency_window"><code class="xref std std-option docutils literal"><span class="pre">latency_window</span></code></a> and <a class="reference internal" href="#cmdoption-arg-latency_percentile"><code class="xref std std-option docutils literal"><span class="pre">latency_percentile</span></code></a></p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-latency_window">
<code class="descname">latency_window</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-latency_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Used with latency_target to specify the sample window
that the job is run at varying queue depths to test the
performance. The value is given in microseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-latency_percentile">
<code class="descname">latency_percentile</code><code class="descclassname">=float</code><a class="headerlink" href="#cmdoption-arg-latency_percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>The percentage of IOs that must fall within the
criteria specified by <a class="reference internal" href="#cmdoption-arg-latency_target"><code class="xref std std-option docutils literal"><span class="pre">latency_target</span></code></a> and <a class="reference internal" href="#cmdoption-arg-latency_window"><code class="xref std std-option docutils literal"><span class="pre">latency_window</span></code></a>. If not
set, this defaults to 100.0, meaning that all IOs must be equal
or below to the value set by <a class="reference internal" href="#cmdoption-arg-latency_target"><code class="xref std std-option docutils literal"><span class="pre">latency_target</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-max_latency">
<code class="descname">max_latency</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-max_latency" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will exit the job if it exceeds this maximum
latency. It will exit with an ETIME error.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_cycle">
<code class="descname">rate_cycle</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rate_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Average bandwidth for &#8216;rate&#8217; and &#8216;rate_min&#8217; over this number
of milliseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpumask">
<code class="descname">cpumask</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-cpumask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the CPU affinity of this job. The parameter given is a
bitmask of allowed CPU&#8217;s the job may run on. So if you want
the allowed CPUs to be 1 and 5, you would pass the decimal
value of (1 &lt;&lt; 1 | 1 &lt;&lt; 5), or 34. See man
<cite>sched_setaffinity(2)</cite>. This may not work on all supported
operating systems or kernel versions. This option doesn&#8217;t
work well for a higher CPU count than what you can store in
an integer mask, so it can only control cpus 1-32. For
boxes with larger CPU counts, use <a class="reference internal" href="#cmdoption-arg-cpus_allowed"><code class="xref std std-option docutils literal"><span class="pre">cpus_allowed</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpus_allowed">
<code class="descname">cpus_allowed</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-cpus_allowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the same options as cpumask, but it allows a text
setting of the permitted CPUs instead. So to use CPUs 1 and
5, you would specify <code class="docutils literal"><span class="pre">cpus_allowed=1,5</span></code>. This options also
allows a range of CPUs. Say you wanted a binding to CPUs
1, 5, and 8-15, you would set <code class="docutils literal"><span class="pre">cpus_allowed=1,5,8-15</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpus_allowed_policy">
<code class="descname">cpus_allowed_policy</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-cpus_allowed_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the policy of how fio distributes the CPUs
specified by cpus_allowed or cpumask. Two policies are
supported:</p>
<p>shared  All jobs will share the CPU set specified.
split   Each job will get a unique CPU from the CPU set.</p>
<p>&#8216;shared&#8217; is the default behaviour, if the option isn&#8217;t
specified. If split is specified, then fio will will assign
one cpu per job. If not enough CPUs are given for the jobs
listed, then fio will roundrobin the CPUs in the set.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-numa_cpu_nodes">
<code class="descname">numa_cpu_nodes</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-numa_cpu_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this job running on specified NUMA nodes&#8217; CPUs. The
arguments allow comma delimited list of cpu numbers,
A-B ranges, or &#8216;all&#8217;. Note, to enable numa options support,
fio must be built on a system with libnuma-dev(el) installed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-numa_mem_policy">
<code class="descname">numa_mem_policy</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-numa_mem_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this job&#8217;s memory policy and corresponding NUMA
nodes. Format of the arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span><span class="p">[:</span><span class="o">&lt;</span><span class="n">nodelist</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">mode</span></code> is one of the following memory policy:
<code class="docutils literal"><span class="pre">default</span></code>, <code class="docutils literal"><span class="pre">prefer</span></code>, <code class="docutils literal"><span class="pre">bind</span></code>, <code class="docutils literal"><span class="pre">interleave</span></code>, <code class="docutils literal"><span class="pre">local</span></code>
For <code class="docutils literal"><span class="pre">default</span></code> and <code class="docutils literal"><span class="pre">local</span></code> memory policy, no node is
needed to be specified.
For <code class="docutils literal"><span class="pre">prefer</span></code>, only one node is allowed.
For <code class="docutils literal"><span class="pre">bind</span></code> and <code class="docutils literal"><span class="pre">interleave</span></code>, it allow comma delimited
list of numbers, A-B ranges, or &#8216;all&#8217;.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-startdelay">
<code class="descname">startdelay</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-startdelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Start this job the specified number of seconds after fio
has started. Only useful if the job file contains several
jobs, and you want to delay starting some jobs to a certain
time.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-runtime">
<code class="descname">runtime</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to terminate processing after the specified number
of seconds. It can be quite hard to determine for how long
a specified job will run, so this parameter is handy to
cap the total runtime to a given time.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-time_based">
<code class="descname">time_based</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-time_based" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will run for the duration of the runtime
specified even if the file(s) are completely read or
written. It will simply loop over the same workload
as many times as the runtime allows.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ramp_time">
<code class="descname">ramp_time</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-ramp_time" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will run the specified workload for this amount
of time before logging any performance numbers. Useful for
letting performance settle before logging results, thus
minimizing the runtime required for stable results. Note
that the ramp_time is considered lead in time for a job,
thus it will increase the total runtime if a special timeout
or runtime is specified.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-steadystate">
<code class="descname">steadystate</code><code class="descclassname">=str:float</code><a class="headerlink" href="#cmdoption-arg-steadystate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ss">
<code class="descname">ss</code><code class="descclassname">=str:float</code><a class="headerlink" href="#cmdoption-arg-ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the criterion and limit for assessing steady state
performance. The first parameter designates the criterion
whereas the second parameter sets the threshold. When the
criterion falls below the threshold for the specified duration,
the job will stop. For example, iops_slope:0.1% will direct fio
to terminate the job when the least squares regression slope
falls below 0.1% of the mean IOPS. If group_reporting is
enabled this will apply to all jobs in the group. Below is the
list of available steady state assessment criteria. All
assessments are carried out using only data from the rolling
collection window. Threshold limits can be expressed as a fixed
value or as a percentage of the mean in the collection window.</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">iops</span></code></dt>
<dd>Collect IOPS data. Stop the job if all
individual IOPS measurements are within the
specified limit of the mean IOPS (e.g., iops:2
means that all individual IOPS values must be
within 2 of the mean, whereas iops:0.2% means
that all individual IOPS values must be within
0.2% of the mean IOPS to terminate the job).</dd>
<dt><code class="docutils literal"><span class="pre">iops_slope</span></code></dt>
<dd>Collect IOPS data and calculate the least
squares regression slope. Stop the job if the
slope falls below the specified limit.</dd>
<dt><code class="docutils literal"><span class="pre">bw</span></code></dt>
<dd>Collect bandwidth data. Stop the job if all
individual bandwidth measurements are within
the specified limit of the mean bandwidth.</dd>
<dt><code class="docutils literal"><span class="pre">bw_slope</span></code></dt>
<dd>Collect bandwidth data and calculate the least
squares regression slope. Stop the job if the
slope falls below the specified limit.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-steadystate_duration">
<code class="descname">steadystate_duration</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-steadystate_duration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ss_dur">
<code class="descname">ss_dur</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-ss_dur" title="Permalink to this definition">¶</a></dt>
<dd><p>A rolling window of this duration will be used to judge whether
steady state has been reached. Data will be collected once per
second. The default is 0 which disables steady state detection.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-steadystate_ramp_time">
<code class="descname">steadystate_ramp_time</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-steadystate_ramp_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ss_ramp">
<code class="descname">ss_ramp</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-ss_ramp" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the job to run for the specified duration before
beginning data collection for checking the steady state job
termination criterion. The default is 0.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-invalidate">
<code class="descname">invalidate</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate the buffer/page cache parts for this file prior
to starting io. Defaults to true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-sync">
<code class="descname">sync</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Use sync io for buffered writes. For the majority of the
io engines, this means using O_SYNC.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iomem">
<code class="descname">iomem</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-iomem" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-mem">
<code class="descname">mem</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-mem" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio can use various types of memory as the io unit buffer.
The allowed values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">malloc</span></code></dt>
<dd>Use memory from <cite>malloc(3)</cite> as the buffers.
Default memory type.</dd>
<dt><code class="docutils literal"><span class="pre">shm</span></code></dt>
<dd>Use shared memory as the buffers. Allocated
through <cite>shmget(2)</cite>.</dd>
<dt><code class="docutils literal"><span class="pre">shmhuge</span></code></dt>
<dd>Same as shm, but use huge pages as backing.</dd>
<dt><code class="docutils literal"><span class="pre">mmap</span></code></dt>
<dd>Use mmap to allocate buffers. May either be
anonymous memory, or can be file backed if
a filename is given after the option. The
format is <cite>mem=mmap:/path/to/file</cite>.</dd>
<dt><code class="docutils literal"><span class="pre">mmaphuge</span></code></dt>
<dd>Use a memory mapped huge file as the buffer
backing. Append filename after mmaphuge, ala
<cite>mem=mmaphuge:/hugetlbfs/file</cite></dd>
<dt><code class="docutils literal"><span class="pre">mmapshared</span></code></dt>
<dd>Same as mmap, but use a MMAP_SHARED
mapping.</dd>
</dl>
</div></blockquote>
<p>The area allocated is a function of the maximum allowed
bs size for the job, multiplied by the io depth given. Note
that for shmhuge and mmaphuge to work, the system must have
free huge pages allocated. This can normally be checked
and set by reading/writing <cite>/proc/sys/vm/nr_hugepages</cite> on a
Linux system. Fio assumes a huge page is 4MB in size. So
to calculate the number of huge pages you need for a given
job file, add up the io depth of all jobs (normally one unless
iodepth= is used) and multiply by the maximum bs set. Then
divide that number by the huge page size. You can see the
size of the huge pages in <cite>/proc/meminfo</cite>. If no huge pages
are allocated by having a non-zero number in nr_hugepages,
using mmaphuge or shmhuge will fail. Also see <a class="reference internal" href="#cmdoption-arg-hugepage-size"><code class="xref std std-option docutils literal"><span class="pre">hugepage-size</span></code></a>.</p>
<p>mmaphuge also needs to have hugetlbfs mounted and the file
location should point there. So if it&#8217;s mounted in <cite>/huge</cite>,
you would use <cite>mem=mmaphuge:/huge/somefile</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iomem_align">
<code class="descname">iomem_align</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iomem_align" title="Permalink to this definition">¶</a></dt>
<dd><p>This indicates the memory alignment of the IO memory buffers.
Note that the given alignment is applied to the first IO unit
buffer, if using iodepth the alignment of the following buffers
are given by the bs used. In other words, if using a bs that is
a multiple of the page sized in the system, all buffers will
be aligned to this value. If using a bs that is not page
aligned, the alignment of subsequent IO memory buffers is the
sum of the <code class="docutils literal"><span class="pre">iomem_align</span></code> and bs used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hugepage-size">
<code class="descname">hugepage-size</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-hugepage-size" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the size of a huge page. Must at least be equal
to the system setting, see <cite>/proc/meminfo</cite>. Defaults to 4MB.
Should probably always be a multiple of megabytes, so using
<code class="docutils literal"><span class="pre">hugepage-size=Xm</span></code> is the preferred way to set this to avoid
setting a non-pow-2 bad value.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exitall">
<code class="descname">exitall</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-exitall" title="Permalink to this definition">¶</a></dt>
<dd><p>When one job finishes, terminate the rest. The default is
to wait for each job to finish, sometimes that is not the
desired action.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exitall_on_error">
<code class="descname">exitall_on_error</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-exitall_on_error" title="Permalink to this definition">¶</a></dt>
<dd><p>When one job finishes in error, terminate the rest. The
default is to wait for each job to finish.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bwavgtime">
<code class="descname">bwavgtime</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-bwavgtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Average the calculated bandwidth over the given time. Value
is specified in milliseconds. If the job also does bandwidth
logging through <a class="reference internal" href="#cmdoption-arg-write_bw_log"><code class="xref std std-option docutils literal"><span class="pre">write_bw_log</span></code></a>, then the minimum of this option
and <a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> will be used.  Default: 500ms.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iopsavgtime">
<code class="descname">iopsavgtime</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iopsavgtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Average the calculated IOPS over the given time. Value
is specified in milliseconds. If the job also does IOPS logging
through <a class="reference internal" href="#cmdoption-arg-write_iops_log"><code class="xref std std-option docutils literal"><span class="pre">write_iops_log</span></code></a>, then the minimum of this option and
<a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> will be used.  Default: 500ms.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_serialize">
<code class="descname">create_serialize</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, serialize the file creation for the jobs.
This may be handy to avoid interleaving of data
files, which may greatly depend on the filesystem
used and even the number of processors in the system.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_fsync">
<code class="descname">create_fsync</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>fsync the data file after creation. This is the
default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_on_open">
<code class="descname">create_on_open</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_on_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t pre-setup the files for IO, just create open()
when it&#8217;s time to do IO to that file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_only">
<code class="descname">create_only</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_only" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio will only run the setup phase of the job.
If files need to be laid out or updated on disk, only
that will be done. The actual job contents are not
executed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-allow_file_create">
<code class="descname">allow_file_create</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-allow_file_create" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio is permitted to create files as part
of its workload. This is the default behavior. If this
option is false, then fio will error out if the files it
needs to use don&#8217;t already exist. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-allow_mounted_write">
<code class="descname">allow_mounted_write</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-allow_mounted_write" title="Permalink to this definition">¶</a></dt>
<dd><p>If this isn&#8217;t set, fio will abort jobs that
are destructive (eg that write) to what appears to be a
mounted device or partition. This should help catch creating
inadvertently destructive tests, not realizing that the test
will destroy data on the mounted file system. Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-pre_read">
<code class="descname">pre_read</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-pre_read" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is given, files will be pre-read into memory before
starting the given IO operation. This will also clear
the &#8216;invalidate&#8217; flag, since it is pointless to pre-read
and then drop the cache. This will only work for IO engines
that are seek-able, since they allow you to read the same data
multiple times. Thus it will not work on eg network or splice
IO.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unlink">
<code class="descname">unlink</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlink the job files when done. Not the default, as repeated
runs of that job would then waste time recreating the file
set again and again.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unlink_each_loop">
<code class="descname">unlink_each_loop</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unlink_each_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlink job files after each iteration or loop.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-loops">
<code class="descname">loops</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the specified number of iterations of this job. Used
to repeat the same workload a given number of times. Defaults
to 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_only">
<code class="descname">verify_only</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-verify_only" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not perform specified workload&#8212;only verify data still
matches previous invocation of this workload. This option
allows one to check data multiple times at a later date
without overwriting it. This option makes sense only for
workloads that write data, and does not support workloads
with the time_based option set.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-do_verify">
<code class="descname">do_verify</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-do_verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the verify phase after a write phase. Only makes sense if
verify is set. Defaults to 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify">
<code class="descname">verify</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-verify" title="Permalink to this definition">¶</a></dt>
<dd><p>If writing to a file, fio can verify the file contents
after each iteration of the job. Each verification method also implies
verification of special header, which is written to the beginning of
each block. This header also includes meta information, like offset
of the block, block number, timestamp when block was written, etc.
<a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> =str can be combined with <a class="reference internal" href="#cmdoption-arg-verify_pattern"><code class="xref std std-option docutils literal"><span class="pre">verify_pattern</span></code></a> =str option.
The allowed values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">md5</span></code></dt>
<dd>Use an md5 sum of the data area and store
it in the header of each block.</dd>
<dt><code class="docutils literal"><span class="pre">crc64</span></code></dt>
<dd>Use an experimental crc64 sum of the data
area and store it in the header of each
block.</dd>
<dt><code class="docutils literal"><span class="pre">crc32c</span></code></dt>
<dd>Use a crc32c sum of the data area and store
it in the header of each block.</dd>
<dt><code class="docutils literal"><span class="pre">crc32c-intel</span></code></dt>
<dd>Use hardware assisted crc32c calculation
provided on SSE4.2 enabled processors. Falls
back to regular software crc32c, if not
supported by the system.</dd>
<dt><code class="docutils literal"><span class="pre">crc32</span></code></dt>
<dd>Use a crc32 sum of the data area and store
it in the header of each block.</dd>
<dt><code class="docutils literal"><span class="pre">crc16</span></code></dt>
<dd>Use a crc16 sum of the data area and store
it in the header of each block.</dd>
<dt><code class="docutils literal"><span class="pre">crc7</span></code></dt>
<dd>Use a crc7 sum of the data area and store
it in the header of each block.</dd>
<dt><code class="docutils literal"><span class="pre">xxhash</span></code></dt>
<dd>Use xxhash as the checksum function. Generally
the fastest software checksum that fio
supports.</dd>
<dt><code class="docutils literal"><span class="pre">sha512</span></code></dt>
<dd>Use sha512 as the checksum function.</dd>
<dt><code class="docutils literal"><span class="pre">sha256</span></code></dt>
<dd>Use sha256 as the checksum function.</dd>
<dt><code class="docutils literal"><span class="pre">sha1</span></code></dt>
<dd>Use optimized sha1 as the checksum function.</dd>
<dt><code class="docutils literal"><span class="pre">meta</span></code></dt>
<dd>This option is deprecated, since now meta information is
included in generic verification header and meta verification
happens by default. For detailed information see the description
of the <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> setting. This option is kept because of
compatibility&#8217;s sake with old configurations. Do not use it.</dd>
<dt><code class="docutils literal"><span class="pre">pattern</span></code></dt>
<dd>Verify a strict pattern. Normally fio includes
a header with some basic information and
checksumming, but if this option is set, only
the specific pattern set with &#8216;verify_pattern&#8217;
is verified.</dd>
<dt><code class="docutils literal"><span class="pre">null</span></code></dt>
<dd>Only pretend to verify. Useful for testing
internals with ioengine=null, not for much
else.</dd>
</dl>
</div></blockquote>
<p>This option can be used for repeated burn-in tests of a
system to make sure that the written data is also
correctly read back. If the data direction given is
a read or random read, fio will assume that it should
verify a previously written file. If the data direction
includes any form of write, the verify will be of the
newly written data.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verifysort">
<code class="descname">verifysort</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verifysort" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will sort written verify blocks when it deems
it faster to read them back in a sorted manner. This is
often the case when overwriting an existing file, since
the blocks are already laid out in the file system. You
can ignore this option unless doing huge amounts of really
fast IO where the red-black tree sorting CPU time becomes
significant.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_offset">
<code class="descname">verify_offset</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the verification header with data somewhere else
in the block before writing. Its swapped back before
verifying.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_interval">
<code class="descname">verify_interval</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the verification header at a finer granularity
than the blocksize. It will be written for chunks the
size of header_interval. blocksize should divide this
evenly.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_pattern">
<code class="descname">verify_pattern</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-verify_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will fill the io buffers with this
pattern. Fio defaults to filling with totally random
bytes, but sometimes it&#8217;s interesting to fill with a known
pattern for io verification purposes. Depending on the
width of the pattern, fio will fill 1/2/3/4 bytes of the
buffer at the time(it can be either a decimal or a hex number).
The verify_pattern if larger than a 32-bit quantity has to
be a hex number that starts with either &#8220;0x&#8221; or &#8220;0X&#8221;. Use
with <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> =str. Also, <code class="docutils literal"><span class="pre">verify_pattern</span></code> supports %o format,
which means that for each block offset will be written and
then verified back, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">verify_pattern</span><span class="o">=%</span><span class="n">o</span>
</pre></div>
</div>
<p>Or use combination of everything:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">verify_pattern</span><span class="o">=</span><span class="mh">0xff</span><span class="o">%</span><span class="n">o</span><span class="s2">&quot;abcd&quot;</span><span class="o">-</span><span class="mi">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_fatal">
<code class="descname">verify_fatal</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_fatal" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will keep checking the entire contents
before quitting on a block verification failure. If this
option is set, fio will exit the job on the first observed
failure.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_dump">
<code class="descname">verify_dump</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, dump the contents of both the original data
block and the data block we read off disk to files. This
allows later analysis to inspect just what kind of data
corruption occurred. Off by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_async">
<code class="descname">verify_async</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio will normally verify IO inline from the submitting
thread. This option takes an integer describing how many
async offload threads to create for IO verification instead,
causing fio to offload the duty of verifying IO contents
to one or more separate threads. If using this offload
option, even sync IO engines can benefit from using an
iodepth setting higher than 1, as it allows them to have
IO in flight while verifies are running.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_async_cpus">
<code class="descname">verify_async_cpus</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-verify_async_cpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to set the given CPU affinity on the
async IO verification threads. See <a class="reference internal" href="#cmdoption-arg-cpus_allowed"><code class="xref std std-option docutils literal"><span class="pre">cpus_allowed</span></code></a> for the
format used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_backlog">
<code class="descname">verify_backlog</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_backlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio will normally verify the written contents of a
job that utilizes verify once that job has completed. In
other words, everything is written then everything is read
back and verified. You may want to verify continually
instead for a variety of reasons. Fio stores the meta data
associated with an IO block in memory, so for large
verify workloads, quite a bit of memory would be used up
holding this meta data. If this option is enabled, fio
will write only N blocks before verifying these blocks.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_backlog_batch">
<code class="descname">verify_backlog_batch</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_backlog_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Control how many blocks fio will verify
if verify_backlog is set. If not set, will default to
the value of verify_backlog (meaning the entire queue
is read back and verified).  If verify_backlog_batch is
less than verify_backlog then not all blocks will be verified,
if verify_backlog_batch is larger than verify_backlog, some
blocks will be verified more than once.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_state_save">
<code class="descname">verify_state_save</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_state_save" title="Permalink to this definition">¶</a></dt>
<dd><p>When a job exits during the write phase of a verify
workload, save its current state. This allows fio to replay
up until that point, if the verify state is loaded for the
verify read phase. The format of the filename is, roughly,
&lt;type&gt;-&lt;jobname&gt;-&lt;jobindex&gt;-verify.state. &lt;type&gt; is &#8220;local&#8221;
for a local run, &#8220;sock&#8221; for a client/server socket connection,
and &#8220;ip&#8221; (192.168.0.1, for instance) for a networked
client/server connection.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_state_load">
<code class="descname">verify_state_load</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_state_load" title="Permalink to this definition">¶</a></dt>
<dd><p>If a verify termination trigger was used, fio stores
the current write state of each thread. This can be used at
verification time so that fio knows how far it should verify.
Without this information, fio will run a full verification
pass, according to the settings in the job file used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-stonewall">
<code class="descname">stonewall</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-stonewall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-wait_for_previous">
<code class="descname">wait_for_previous</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-wait_for_previous" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for preceding jobs in the job file to exit, before
starting this one. Can be used to insert serialization
points in the job file. A stone wall also implies starting
a new reporting group.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-new_group">
<code class="descname">new_group</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-new_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a new reporting group. See: <a class="reference internal" href="#cmdoption-arg-group_reporting"><code class="xref std std-option docutils literal"><span class="pre">group_reporting</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-numjobs">
<code class="descname">numjobs</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-numjobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the specified number of clones of this job. May be
used to setup a larger number of threads/processes doing
the same thing. Each thread is reported separately; to see
statistics for all clones as a whole, use group_reporting in
conjunction with new_group.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-group_reporting">
<code class="descname">group_reporting</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-group_reporting" title="Permalink to this definition">¶</a></dt>
<dd><p>It may sometimes be interesting to display statistics for
groups of jobs as a whole instead of for each individual job.
This is especially true if &#8216;numjobs&#8217; is used; looking at
individual thread/process output quickly becomes unwieldy.
To see the final report per-group instead of per-job, use
&#8216;group_reporting&#8217;. Jobs in a file will be part of the same
reporting group, unless if separated by a stonewall, or by
using &#8216;new_group&#8217;.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-thread">
<code class="descname">thread</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-thread" title="Permalink to this definition">¶</a></dt>
<dd><p>fio defaults to forking jobs, however if this option is
given, fio will use <cite>pthread_create(3)</cite> to create threads
instead.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-zonesize">
<code class="descname">zonesize</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-zonesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide a file into zones of the specified size. See <a class="reference internal" href="#cmdoption-arg-zoneskip"><code class="xref std std-option docutils literal"><span class="pre">zoneskip</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-zoneskip">
<code class="descname">zoneskip</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-zoneskip" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip the specified number of bytes when zonesize data has
been read. The two zone options can be used to only do
io on zones of a file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_iolog">
<code class="descname">write_iolog</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_iolog" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the issued io patterns to the specified file. See
<a class="reference internal" href="#cmdoption-arg-read_iolog"><code class="xref std std-option docutils literal"><span class="pre">read_iolog</span></code></a>.  Specify a separate file for each job, otherwise
the iologs will be interspersed and the file may be corrupt.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-read_iolog">
<code class="descname">read_iolog</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-read_iolog" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an iolog with the specified file name and replay the
io patterns it contains. This can be used to store a
workload and replay it sometime later. The iolog given
may also be a blktrace binary file, which allows fio
to replay a workload captured by blktrace. See blktrace
for how to capture such logging data. For blktrace replay,
the file needs to be turned into a blkparse binary data
file first (<code class="docutils literal"><span class="pre">blkparse</span> <span class="pre">&lt;device&gt;</span> <span class="pre">-o</span> <span class="pre">/dev/null</span> <span class="pre">-d</span> <span class="pre">file_for_fio.bin</span></code>).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_no_stall">
<code class="descname">replay_no_stall</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-replay_no_stall" title="Permalink to this definition">¶</a></dt>
<dd><p>When replaying I/O with read_iolog the default behavior
is to attempt to respect the time stamps within the log and
replay them with the appropriate delay between IOPS. By
setting this variable fio will not respect the timestamps and
attempt to replay them as fast as possible while still
respecting ordering. The result is the same I/O pattern to a
given device, but different timings.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_redirect">
<code class="descname">replay_redirect</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-replay_redirect" title="Permalink to this definition">¶</a></dt>
<dd><p>While replaying I/O patterns using read_iolog the
default behavior is to replay the IOPS onto the major/minor
device that each IOP was recorded from.  This is sometimes
undesirable because on a different machine those major/minor
numbers can map to a different device.  Changing hardware on
the same system can also result in a different major/minor
mapping.  Replay_redirect causes all IOPS to be replayed onto
the single specified device regardless of the device it was
recorded from. i.e. <code class="docutils literal"><span class="pre">replay_redirect=/dev/sdc</span></code> would cause all
IO in the blktrace or iolog to be replayed onto <code class="docutils literal"><span class="pre">/dev/sdc</span></code>.
This means multiple devices will be replayed onto a single
device, if the trace contains multiple devices. If you want
multiple devices to be replayed concurrently to multiple
redirected devices you must blkparse your trace into separate
traces and replay them with independent fio invocations.
Unfortunately this also breaks the strict time ordering
between multiple device accesses.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_align">
<code class="descname">replay_align</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-replay_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Force alignment of IO offsets and lengths in a trace
to this power of 2 value.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_scale">
<code class="descname">replay_scale</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-replay_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale sector offsets down by this factor when
replaying traces.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-per_job_logs">
<code class="descname">per_job_logs</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-per_job_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, this generates bw/clat/iops log with per
file private filenames. If not set, jobs with identical names
will share the log filename. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_bw_log">
<code class="descname">write_bw_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_bw_log" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, write a bandwidth log of the jobs in this job
file. Can be used to store data of the bandwidth of the
jobs in their lifetime. The included fio_generate_plots
script uses gnuplot to turn these text files into nice
graphs. See <a class="reference internal" href="#cmdoption-arg-write_lat_log"><code class="xref std std-option docutils literal"><span class="pre">write_lat_log</span></code></a> for behaviour of given
filename. For this option, the suffix is _bw.x.log, where
x is the index of the job (1..N, where N is the number of
jobs). If <a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then the filename will not
include the job index. See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_lat_log">
<code class="descname">write_lat_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_lat_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as write_bw_log, except that this option stores io
submission, completion, and total latencies instead. If no
filename is given with this option, the default filename of
&#8220;jobname_type.log&#8221; is used. Even if the filename is given,
fio will still append the type of log. So if one specifies</p>
<p>write_lat_log=foo</p>
<p>The actual log names will be foo_slat.x.log, foo_clat.x.log,
and foo_lat.x.log, where x is the index of the job (1..N,
where N is the number of jobs). This helps fio_generate_plot
find the logs automatically. If <a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then
the filename will not include the job index. See <a class="reference internal" href="#log-file-formats">Log File
Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_hist_log">
<code class="descname">write_hist_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_hist_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as write_lat_log, but writes I/O completion
latency histograms. If no filename is given with this option, the
default filename of &#8220;jobname_clat_hist.x.log&#8221; is used, where x is
the index of the job (1..N, where N is the number of jobs). Even
if the filename is given, fio will still append the type of log.
If <a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then the filename will not include the
job index. See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_iops_log">
<code class="descname">write_iops_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_iops_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#cmdoption-arg-write_bw_log"><code class="xref std std-option docutils literal"><span class="pre">write_bw_log</span></code></a>, but writes IOPS. If no filename is
given with this option, the default filename of
&#8220;jobname_type.x.log&#8221; is used,where x is the index of the job
(1..N, where N is the number of jobs). Even if the filename
is given, fio will still append the type of log. If
<a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then the filename will not include
the job index. See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_avg_msec">
<code class="descname">log_avg_msec</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_avg_msec" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, fio will log an entry in the iops, latency,
or bw log for every IO that completes. When writing to the
disk log, that can quickly grow to a very large size. Setting
this option makes fio average the each log entry over the
specified period of time, reducing the resolution of the log.
See <a class="reference internal" href="#cmdoption-arg-log_max_value"><code class="xref std std-option docutils literal"><span class="pre">log_max_value</span></code></a> as well. Defaults to 0, logging all entries.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_hist_msec">
<code class="descname">log_hist_msec</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_hist_msec" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as log_avg_msec, but logs entries for completion
latency histograms. Computing latency percentiles from averages of
intervals using <a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> is innacurate. Setting this option makes
fio log histogram entries over the specified period of time, reducing
log sizes for high IOPS devices while retaining percentile accuracy.
See <a class="reference internal" href="#cmdoption-arg-log_hist_coarseness"><code class="xref std std-option docutils literal"><span class="pre">log_hist_coarseness</span></code></a> as well. Defaults to 0, meaning histogram
logging is disabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_hist_coarseness">
<code class="descname">log_hist_coarseness</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_hist_coarseness" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer ranging from 0 to 6, defining the coarseness
of the resolution of the histogram logs enabled with log_hist_msec. For
each increment in coarseness, fio outputs half as many bins. Defaults to
0, for which histogram logs contain 1216 latency bins. See
<a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_max_value">
<code class="descname">log_max_value</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-log_max_value" title="Permalink to this definition">¶</a></dt>
<dd><p>If log_avg_msec is set, fio logs the average over that
window. If you instead want to log the maximum value, set this
option to 1. Defaults to 0, meaning that averaged values are
logged.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_offset">
<code class="descname">log_offset</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is set, the iolog options will include the byte
offset for the IO entry as well as the other data values.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_compression">
<code class="descname">log_compression</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_compression" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is set, fio will compress the IO logs as
it goes, to keep the memory footprint lower. When a log
reaches the specified size, that chunk is removed and
compressed in the background. Given that IO logs are
fairly highly compressible, this yields a nice memory
savings for longer runs. The downside is that the
compression will consume some background CPU cycles, so
it may impact the run. This, however, is also true if
the logging ends up consuming most of the system memory.
So pick your poison. The IO logs are saved normally at the
end of a run, by decompressing the chunks and storing them
in the specified log file. This feature depends on the
availability of zlib.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_compression_cpus">
<code class="descname">log_compression_cpus</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-log_compression_cpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the set of CPUs that are allowed to
handle online log compression for the IO jobs. This can
provide better isolation between performance sensitive jobs,
and background compression work.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_store_compressed">
<code class="descname">log_store_compressed</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-log_store_compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will store the log files in a
compressed format. They can be decompressed with fio, using
the &#8211;inflate-log command line parameter. The files will be
stored with a .fz suffix.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_unix_epoch">
<code class="descname">log_unix_epoch</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-log_unix_epoch" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will log Unix timestamps to the log
files produced by enabling write_type_log for each log type, instead
of the default zero-based timestamps.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-block_error_percentiles">
<code class="descname">block_error_percentiles</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-block_error_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, record errors in trim block-sized
units from writes and trims and output a histogram of
how many trims it took to get to errors, and what kind
of error was encountered.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-lockmem">
<code class="descname">lockmem</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-lockmem" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin down the specified amount of memory with <cite>mlock(2)</cite>. Can
potentially be used instead of removing memory or booting
with less memory to simulate a smaller amount of memory.
The amount specified is per worker.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exec_prerun">
<code class="descname">exec_prerun</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-exec_prerun" title="Permalink to this definition">¶</a></dt>
<dd><p>Before running this job, issue the command specified
through <cite>system(3)</cite>. Output is redirected in a file called
jobname.prerun.txt.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exec_postrun">
<code class="descname">exec_postrun</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-exec_postrun" title="Permalink to this definition">¶</a></dt>
<dd><p>After the job completes, issue the command specified
though <cite>system(3)</cite>. Output is redirected in a file called
jobname.postrun.txt.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ioscheduler">
<code class="descname">ioscheduler</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-ioscheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to switch the device hosting the file to the specified
io scheduler before running.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disk_util">
<code class="descname">disk_util</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disk_util" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate disk utilization statistics, if the platform
supports it. Defaults to on.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_lat">
<code class="descname">disable_lat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_lat" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of total latency numbers. Useful
only for cutting back the number of calls to gettimeofday,
as that does impact performance at really high IOPS rates.
Note that to really get rid of a large amount of these
calls, this option must be used with <a class="reference internal" href="#cmdoption-arg-disable_slat"><code class="xref std std-option docutils literal"><span class="pre">disable_slat</span></code></a> and
<a class="reference internal" href="#cmdoption-arg-disable_bw"><code class="xref std std-option docutils literal"><span class="pre">disable_bw</span></code></a> as well.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_clat">
<code class="descname">disable_clat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_clat" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of completion latency numbers. See
<a class="reference internal" href="#cmdoption-arg-disable_lat"><code class="xref std std-option docutils literal"><span class="pre">disable_lat</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_slat">
<code class="descname">disable_slat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_slat" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of submission latency numbers. See
<a class="reference internal" href="#cmdoption-arg-disable_slat"><code class="xref std std-option docutils literal"><span class="pre">disable_slat</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_bw">
<code class="descname">disable_bw</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_bw" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of throughput/bandwidth numbers. See
<a class="reference internal" href="#cmdoption-arg-disable_lat"><code class="xref std std-option docutils literal"><span class="pre">disable_lat</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clat_percentiles">
<code class="descname">clat_percentiles</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-clat_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the reporting of percentiles of
completion latencies.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-percentile_list">
<code class="descname">percentile_list</code><code class="descclassname">=float_list</code><a class="headerlink" href="#cmdoption-arg-percentile_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite the default list of percentiles
for completion latencies and the block error histogram.
Each number is a floating number in the range (0,100],
and the maximum length of the list is 20. Use &#8216;:&#8217;
to separate the numbers, and list the numbers in ascending
order. For example, &#8211;percentile_list=99.5:99.9 will cause
fio to report the values of completion latency below which
99.5% and 99.9% of the observed latencies fell, respectively.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clocksource">
<code class="descname">clocksource</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-clocksource" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the given clocksource as the base of timing. The
supported options are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gettimeofday</span></code></dt>
<dd><cite>gettimeofday(2)</cite></dd>
<dt><code class="docutils literal"><span class="pre">clock_gettime</span></code></dt>
<dd><cite>clock_gettime(2)</cite></dd>
<dt><code class="docutils literal"><span class="pre">cpu</span></code></dt>
<dd>Internal CPU clock source</dd>
</dl>
</div></blockquote>
<p>cpu is the preferred clocksource if it is reliable, as it
is very fast (and fio is heavy on time calls). Fio will
automatically use this clocksource if it&#8217;s supported and
considered reliable on the system it is running on, unless
another clocksource is specifically set. For x86/x86-64 CPUs,
this means supporting TSC Invariant.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-gtod_reduce">
<code class="descname">gtod_reduce</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-gtod_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable all of the <cite>gettimeofday()</cite> reducing options
(disable_clat, disable_slat, disable_bw) plus reduce
precision of the timeout somewhat to really shrink
the <cite>gettimeofday()</cite> call count. With this option enabled,
we only do about 0.4% of the gtod() calls we would have
done if all time keeping was enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-gtod_cpu">
<code class="descname">gtod_cpu</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-gtod_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes it&#8217;s cheaper to dedicate a single thread of
execution to just getting the current time. Fio (and
databases, for instance) are very intensive on <cite>gettimeofday()</cite>
calls. With this option, you can set one CPU aside for
doing nothing but logging current time to a shared memory
location. Then the other threads/processes that run IO
workloads need only copy that segment, instead of entering
the kernel with a <cite>gettimeofday()</cite> call. The CPU set aside
for doing these time calls will be excluded from other
uses. Fio will manually clear it from the CPU mask of other
jobs.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-continue_on_error">
<code class="descname">continue_on_error</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-continue_on_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will exit the job on the first observed
failure. If this option is set, fio will continue the job when
there is a &#8216;non-fatal error&#8217; (EIO or EILSEQ) until the runtime
is exceeded or the I/O size specified is completed. If this
option is used, there are two more stats that are appended,
the total error count and the first error. The error field
given in the stats is the first error that was hit during the
run.</p>
<p>The allowed values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">none</span></code></dt>
<dd>Exit on any IO or verify errors.</dd>
<dt><code class="docutils literal"><span class="pre">read</span></code></dt>
<dd>Continue on read errors, exit on all others.</dd>
<dt><code class="docutils literal"><span class="pre">write</span></code></dt>
<dd>Continue on write errors, exit on all others.</dd>
<dt><code class="docutils literal"><span class="pre">io</span></code></dt>
<dd>Continue on any IO error, exit on all others.</dd>
<dt><code class="docutils literal"><span class="pre">verify</span></code></dt>
<dd>Continue on verify errors, exit on all others.</dd>
<dt><code class="docutils literal"><span class="pre">all</span></code></dt>
<dd>Continue on all errors.</dd>
<dt><code class="docutils literal"><span class="pre">0</span></code></dt>
<dd>Backward-compatible alias for &#8216;none&#8217;.</dd>
<dt><code class="docutils literal"><span class="pre">1</span></code></dt>
<dd>Backward-compatible alias for &#8216;all&#8217;.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ignore_error">
<code class="descname">ignore_error</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-ignore_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes you want to ignore some errors during test
in that case you can specify error list for each error type.
ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST
errors for given error type is separated with &#8216;:&#8217;. Error
may be symbol (&#8216;ENOSPC&#8217;, &#8216;ENOMEM&#8217;) or integer.
Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ignore_error</span><span class="o">=</span><span class="n">EAGAIN</span><span class="p">,</span><span class="n">ENOSPC</span><span class="p">:</span><span class="mi">122</span>
</pre></div>
</div>
<p>This option will ignore EAGAIN from READ, and ENOSPC and
122(EDQUOT) from WRITE.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-error_dump">
<code class="descname">error_dump</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-error_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>If set dump every error even if it is non fatal, true
by default. If disabled only fatal error will be dumped</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cgroup">
<code class="descname">cgroup</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-cgroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Add job to this control group. If it doesn&#8217;t exist, it will
be created. The system must have a mounted cgroup blkio
mount point for this to work. If your system doesn&#8217;t have it
mounted, you can do so with:</p>
<p># mount -t cgroup -o blkio none /cgroup</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cgroup_weight">
<code class="descname">cgroup_weight</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-cgroup_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the weight of the cgroup to this value. See
the documentation that comes with the kernel, allowed values
are in the range of 100..1000.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cgroup_nodelete">
<code class="descname">cgroup_nodelete</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-cgroup_nodelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will delete the cgroups it has created after
the job completion. To override this behavior and to leave
cgroups around after the job completion, set cgroup_nodelete=1.
This can be useful if one wants to inspect various cgroup
files after job completion. Default: false</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-uid">
<code class="descname">uid</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-uid" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of running as the invoking user, set the user ID to
this value before the thread/process does any work.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-gid">
<code class="descname">gid</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set group ID, see uid.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow_id">
<code class="descname">flow_id</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The ID of the flow. If not specified, it defaults to being a
global flow. See flow.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow">
<code class="descname">flow</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight in token-based flow control. If this value is used, then
there is a &#8216;flow counter&#8217; which is used to regulate the
proportion of activity between two or more jobs. fio attempts
to keep this flow counter near zero. The &#8216;flow&#8217; parameter
stands for how much should be added or subtracted to the flow
counter on each iteration of the main I/O loop. That is, if
one job has flow=8 and another job has flow=-1, then there
will be a roughly 1:8 ratio in how much one runs vs the other.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow_watermark">
<code class="descname">flow_watermark</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow_watermark" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum value that the absolute value of the flow
counter is allowed to reach before the job must wait for a
lower value of the counter.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow_sleep">
<code class="descname">flow_sleep</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>The period of time, in microseconds, to wait after the flow
watermark has been exceeded before retrying operations</p>
</dd></dl>

<p>In addition, there are some parameters which are only valid when a specific
ioengine is in use. These are used identically to normal parameters, with the
caveat that when used on the command line, they must come after the ioengine
that defines them is selected.</p>
<dl class="option">
<dt id="cmdoption-arg-userspace_reap">
<code class="descname">userspace_reap</code><code class="descclassname"> : [libaio]</code><a class="headerlink" href="#cmdoption-arg-userspace_reap" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally, with the libaio engine in use, fio will use
the io_getevents system call to reap newly returned events.
With this flag turned on, the AIO ring will be read directly
from user-space to reap events. The reaping mode is only
enabled when polling for a minimum of 0 events (eg when
iodepth_batch_complete=0).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hipri">
<code class="descname">hipri</code><code class="descclassname"> : [psyncv2]</code><a class="headerlink" href="#cmdoption-arg-hipri" title="Permalink to this definition">¶</a></dt>
<dd><p>Set RWF_HIPRI on IO, indicating to the kernel that
it&#8217;s of higher priority than normal.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpuload">
<code class="descname">cpuload</code><code class="descclassname">=int : [cpuio]</code><a class="headerlink" href="#cmdoption-arg-cpuload" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to use the specified percentage of CPU cycles.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpuchunks">
<code class="descname">cpuchunks</code><code class="descclassname">=int : [cpuio]</code><a class="headerlink" href="#cmdoption-arg-cpuchunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the load into cycles of the given time. In
microseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exit_on_io_done">
<code class="descname">exit_on_io_done</code><code class="descclassname">=bool : [cpuio]</code><a class="headerlink" href="#cmdoption-arg-exit_on_io_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect when IO threads are done, then exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hostname">
<code class="descname">hostname</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-hostname" title="Permalink to this definition">¶</a></dt>
<dd><p>The host name or IP address to use for TCP or UDP based IO.
If the job is a TCP listener or UDP reader, the hostname is not
used and must be omitted unless it is a valid UDP multicast
address.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-namenode">
<code class="descname">namenode</code><code class="descclassname">=str : [libhdfs]</code><a class="headerlink" href="#cmdoption-arg-namenode" title="Permalink to this definition">¶</a></dt>
<dd><p>The host name or IP address of a HDFS cluster namenode to contact.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-port">
<code class="descname">port</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-port" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>[netsplice], [net]</dt>
<dd>The TCP or UDP port to bind to or connect to. If this is used
with numjobs to spawn multiple instances of the same job type, then this will
be the starting port number since fio will use a range of ports.</dd>
<dt>[libhdfs]</dt>
<dd>the listening port of the HFDS cluster namenode.</dd>
</dl>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-interface">
<code class="descname">interface</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-interface" title="Permalink to this definition">¶</a></dt>
<dd><p>The IP address of the network interface used to send or
receive UDP multicast</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ttl">
<code class="descname">ttl</code><code class="descclassname">=int : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-ttl" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-to-live value for outgoing UDP multicast packets.
Default: 1</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-nodelay">
<code class="descname">nodelay</code><code class="descclassname">=bool : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-nodelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Set TCP_NODELAY on TCP connections.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-protocol">
<code class="descname">protocol</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-protocol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-proto">
<code class="descname">proto</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-proto" title="Permalink to this definition">¶</a></dt>
<dd><p>The network protocol to use. Accepted values are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">tcp</span></code>       Transmission control protocol</li>
<li><code class="docutils literal"><span class="pre">tcpv6</span></code>     Transmission control protocol V6</li>
<li><code class="docutils literal"><span class="pre">udp</span></code>       User datagram protocol</li>
<li><code class="docutils literal"><span class="pre">udpv6</span></code>     User datagram protocol V6</li>
<li><code class="docutils literal"><span class="pre">unix</span></code>      UNIX domain socket</li>
</ul>
</div></blockquote>
<p>When the protocol is TCP or UDP, the port must also be given,
as well as the hostname if the job is a TCP listener or UDP
reader. For unix sockets, the normal filename option should be
used and the port is invalid.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-listen">
<code class="descname">listen</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-listen" title="Permalink to this definition">¶</a></dt>
<dd><p>For TCP network connections, tell fio to listen for incoming
connections rather than initiating an outgoing connection. The
hostname must be omitted if this option is used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-pingpong">
<code class="descname">pingpong</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-pingpong" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally a network writer will just continue writing data, and
a network reader will just consume packages. If <code class="docutils literal"><span class="pre">pingpong=1</span></code>
is set, a writer will send its normal payload to the reader,
then wait for the reader to send the same payload back. This
allows fio to measure network latencies. The submission
and completion latencies then measure local time spent
sending or receiving, and the completion latency measures
how long it took for the other end to receive and send back.
For UDP multicast traffic <code class="docutils literal"><span class="pre">pingpong=1</span></code> should only be set for a
single reader when multiple readers are listening to the same
address.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-window_size">
<code class="descname">window_size</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-window_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the desired socket buffer size for the connection.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-mss">
<code class="descname">mss</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-mss" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the TCP maximum segment size (TCP_MAXSEG).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-donorname">
<code class="descname">donorname</code><code class="descclassname">=str : [e4defrag]</code><a class="headerlink" href="#cmdoption-arg-donorname" title="Permalink to this definition">¶</a></dt>
<dd><p>File will be used as a block donor(swap extents between files)</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-inplace">
<code class="descname">inplace</code><code class="descclassname">=int : [e4defrag]</code><a class="headerlink" href="#cmdoption-arg-inplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure donor file blocks allocation strategy</p>
<ul class="simple">
<li>0(default): Preallocate donor&#8217;s file on init</li>
<li>1       : allocate space immediately inside defragment event,
and free right after event</li>
</ul>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clustername">
<code class="descname">clustername</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-clustername" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the Ceph cluster.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rbdname">
<code class="descname">rbdname</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-rbdname" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the RBD.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-pool">
<code class="descname">pool</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the Ceph pool containing RBD.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clientname">
<code class="descname">clientname</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-clientname" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the username (without the &#8216;client.&#8217; prefix)
used to access the Ceph cluster. If the clustername is
specified, the clientname shall be the full type.id
string. If no type. prefix is given, fio will add
&#8216;client.&#8217; by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-skip_bad">
<code class="descname">skip_bad</code><code class="descclassname">=bool : [mtd]</code><a class="headerlink" href="#cmdoption-arg-skip_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip operations against known bad blocks.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hdfsdirectory">
<code class="descname">hdfsdirectory</code><code class="descclassname"> : [libhdfs]</code><a class="headerlink" href="#cmdoption-arg-hdfsdirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>libhdfs will create chunk in this HDFS directory</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-chunk_size">
<code class="descname">chunk_size</code><code class="descclassname"> : [libhdfs]</code><a class="headerlink" href="#cmdoption-arg-chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>the size of the chunk to use for each file.</p>
</dd></dl>

</div>
<div class="section" id="interpreting-the-output">
<h2>2.6. Interpreting the output<a class="headerlink" href="#interpreting-the-output" title="Permalink to this headline">¶</a></h2>
<p>fio spits out a lot of output. While running, fio will display the
status of the jobs created. An example of that would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Threads</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">_r</span><span class="p">]</span> <span class="p">[</span><span class="mf">24.8</span><span class="o">%</span> <span class="n">done</span><span class="p">]</span> <span class="p">[</span> <span class="mi">13509</span><span class="o">/</span>  <span class="mi">8334</span> <span class="n">kb</span><span class="o">/</span><span class="n">s</span><span class="p">]</span> <span class="p">[</span><span class="n">eta</span> <span class="mi">00</span><span class="n">h</span><span class="p">:</span><span class="mi">01</span><span class="n">m</span><span class="p">:</span><span class="mi">31</span><span class="n">s</span><span class="p">]</span>
</pre></div>
</div>
<p>The characters inside the square brackets denote the current status of
each thread. The possible values (in typical life cycle order) are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="7%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Idle</th>
<th class="head">Run</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P</td>
<td>&nbsp;</td>
<td>Thread setup, but not started.</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>&nbsp;</td>
<td>Thread created.</td>
</tr>
<tr class="row-even"><td>I</td>
<td>&nbsp;</td>
<td>Thread initialized, waiting or generating necessary data.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>p</td>
<td>Thread running pre-reading file(s).</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>R</td>
<td>Running, doing sequential reads.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>r</td>
<td>Running, doing random reads.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>W</td>
<td>Running, doing sequential writes.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>w</td>
<td>Running, doing random writes.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>M</td>
<td>Running, doing mixed sequential reads/writes.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>m</td>
<td>Running, doing mixed random reads/writes.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>F</td>
<td>Running, currently waiting for fsync()</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>V</td>
<td>Running, doing verification of written data.</td>
</tr>
<tr class="row-even"><td>E</td>
<td>&nbsp;</td>
<td>Thread exited, not reaped by main thread yet.</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&nbsp;</td>
<td>Thread reaped, or</td>
</tr>
<tr class="row-even"><td>X</td>
<td>&nbsp;</td>
<td>Thread reaped, exited with an error.</td>
</tr>
<tr class="row-odd"><td>K</td>
<td>&nbsp;</td>
<td>Thread reaped, exited due to signal.</td>
</tr>
</tbody>
</table>
<p>Fio will condense the thread string as not to take up more space on the
command line as is needed. For instance, if you have 10 readers and 10
writers running, the output would look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Jobs</span><span class="p">:</span> <span class="mi">20</span> <span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="n">W</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span> <span class="p">[</span><span class="mf">4.0</span><span class="o">%</span> <span class="n">done</span><span class="p">]</span> <span class="p">[</span><span class="mi">2103</span><span class="n">MB</span><span class="o">/</span><span class="mi">0</span><span class="n">KB</span><span class="o">/</span><span class="mi">0</span><span class="n">KB</span> <span class="o">/</span><span class="n">s</span><span class="p">]</span> <span class="p">[</span><span class="mi">538</span><span class="n">K</span><span class="o">/</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span> <span class="n">iops</span><span class="p">]</span> <span class="p">[</span><span class="n">eta</span> <span class="mi">57</span><span class="n">m</span><span class="p">:</span><span class="mi">36</span><span class="n">s</span><span class="p">]</span>
</pre></div>
</div>
<p>Fio will still maintain the ordering, though. So the above means that jobs
1..10 are readers, and 11..20 are writers.</p>
<p>The other values are fairly self explanatory - number of threads
currently running and doing io, rate of io since last check (read speed
listed first, then write speed), and the estimated completion percentage
and time for the running group. It&#8217;s impossible to estimate runtime of
the following groups (if any). Note that the string is displayed in order,
so it&#8217;s possible to tell which of the jobs are currently doing what. The
first character is the first job defined in the job file, and so forth.</p>
<p>When fio is done (or interrupted by ctrl-c), it will show the data for
each thread, group of threads, and disks in that order. For each data
direction, the output looks like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Client1</span> <span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="n">err</span><span class="o">=</span> <span class="mi">0</span><span class="p">:</span>
  <span class="n">write</span><span class="p">:</span> <span class="n">io</span><span class="o">=</span>    <span class="mi">32</span><span class="n">MB</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span>   <span class="mi">666</span><span class="n">KB</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">iops</span><span class="o">=</span><span class="mi">89</span> <span class="p">,</span> <span class="n">runt</span><span class="o">=</span> <span class="mi">50320</span><span class="n">msec</span>
    <span class="n">slat</span> <span class="p">(</span><span class="n">msec</span><span class="p">):</span> <span class="nb">min</span><span class="o">=</span>    <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span>  <span class="mi">136</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">stdev</span><span class="o">=</span> <span class="mf">1.92</span>
    <span class="n">clat</span> <span class="p">(</span><span class="n">msec</span><span class="p">):</span> <span class="nb">min</span><span class="o">=</span>    <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span>  <span class="mi">631</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="mf">48.50</span><span class="p">,</span> <span class="n">stdev</span><span class="o">=</span><span class="mf">86.82</span>
     <span class="n">bw</span> <span class="p">(</span><span class="n">KB</span><span class="o">/</span><span class="n">s</span><span class="p">)</span> <span class="p">:</span> <span class="nb">min</span><span class="o">=</span>    <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">1196</span><span class="p">,</span> <span class="n">per</span><span class="o">=</span><span class="mf">51.00</span><span class="o">%</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="mf">664.02</span><span class="p">,</span> <span class="n">stdev</span><span class="o">=</span><span class="mf">681.68</span>
     <span class="n">cpu</span>       <span class="p">:</span> <span class="n">usr</span><span class="o">=</span><span class="mf">1.49</span><span class="o">%</span><span class="p">,</span> <span class="n">sys</span><span class="o">=</span><span class="mf">0.25</span><span class="o">%</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="mi">7969</span><span class="p">,</span> <span class="n">majf</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">minf</span><span class="o">=</span><span class="mi">17</span>
     <span class="n">IO</span> <span class="n">depths</span> <span class="p">:</span> <span class="mi">1</span><span class="o">=</span><span class="mf">0.1</span><span class="o">%</span><span class="p">,</span> <span class="mi">2</span><span class="o">=</span><span class="mf">0.3</span><span class="o">%</span><span class="p">,</span> <span class="mi">4</span><span class="o">=</span><span class="mf">0.5</span><span class="o">%</span><span class="p">,</span> <span class="mi">8</span><span class="o">=</span><span class="mf">99.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">16</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">32</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="o">&gt;</span><span class="mi">32</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span>
     <span class="n">submit</span>    <span class="p">:</span> <span class="mi">0</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">4</span><span class="o">=</span><span class="mf">100.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">8</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">16</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">32</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">64</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="o">&gt;=</span><span class="mi">64</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span>
     <span class="n">complete</span>  <span class="p">:</span> <span class="mi">0</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">4</span><span class="o">=</span><span class="mf">100.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">8</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">16</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">32</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">64</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="o">&gt;=</span><span class="mi">64</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span>
     <span class="n">issued</span> <span class="n">r</span><span class="o">/</span><span class="n">w</span><span class="p">:</span> <span class="n">total</span><span class="o">=</span><span class="mi">0</span><span class="o">/</span><span class="mi">32768</span><span class="p">,</span> <span class="n">short</span><span class="o">=</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span>
     <span class="n">lat</span> <span class="p">(</span><span class="n">msec</span><span class="p">):</span> <span class="mi">2</span><span class="o">=</span><span class="mf">1.6</span><span class="o">%</span><span class="p">,</span> <span class="mi">4</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">10</span><span class="o">=</span><span class="mf">3.2</span><span class="o">%</span><span class="p">,</span> <span class="mi">20</span><span class="o">=</span><span class="mf">12.8</span><span class="o">%</span><span class="p">,</span> <span class="mi">50</span><span class="o">=</span><span class="mf">38.4</span><span class="o">%</span><span class="p">,</span> <span class="mi">100</span><span class="o">=</span><span class="mf">24.8</span><span class="o">%</span><span class="p">,</span>
     <span class="n">lat</span> <span class="p">(</span><span class="n">msec</span><span class="p">):</span> <span class="mi">250</span><span class="o">=</span><span class="mf">15.2</span><span class="o">%</span><span class="p">,</span> <span class="mi">500</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">750</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="mi">1000</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span><span class="p">,</span> <span class="o">&gt;=</span><span class="mi">2048</span><span class="o">=</span><span class="mf">0.0</span><span class="o">%</span>
</pre></div>
</div>
<p>The client number is printed, along with the group id and error of that
thread. Below is the io statistics, here for writes. In the order listed,
they denote:</p>
<dl class="docutils">
<dt><strong>io=</strong></dt>
<dd>Number of megabytes io performed</dd>
<dt><strong>bw=</strong></dt>
<dd>Average bandwidth rate</dd>
<dt><strong>iops=</strong></dt>
<dd>Average IOs performed per second</dd>
<dt><strong>runt=</strong></dt>
<dd>The runtime of that thread</dd>
<dt><strong>slat=</strong></dt>
<dd>Submission latency (avg being the average, stdev being the
standard deviation). This is the time it took to submit
the io. For sync io, the slat is really the completion
latency, since queue/complete is one operation there. This
value can be in milliseconds or microseconds, fio will choose
the most appropriate base and print that. In the example
above, milliseconds is the best scale. Note: in <cite>&#8211;minimal</cite> mode
latencies are always expressed in microseconds.</dd>
<dt><strong>clat=</strong></dt>
<dd>Completion latency. Same names as slat, this denotes the
time from submission to completion of the io pieces. For
sync io, clat will usually be equal (or very close) to 0,
as the time from submit to complete is basically just
CPU time (io has already been done, see slat explanation).</dd>
<dt><strong>bw=</strong></dt>
<dd>Bandwidth. Same names as the xlat stats, but also includes
an approximate percentage of total aggregate bandwidth
this thread received in this group. This last value is
only really useful if the threads in this group are on the
same disk, since they are then competing for disk access.</dd>
<dt><strong>cpu=</strong></dt>
<dd>CPU usage. User and system time, along with the number
of context switches this thread went through, usage of
system and user time, and finally the number of major
and minor page faults. The CPU utilization numbers are
averages for the jobs in that reporting group, while the
context and fault counters are summed.</dd>
<dt><strong>IO depths=</strong></dt>
<dd>The distribution of io depths over the job life time. The
numbers are divided into powers of 2, so for example the
16= entries includes depths up to that value but higher
than the previous entry. In other words, it covers the
range from 16 to 31.</dd>
<dt><strong>IO submit=</strong></dt>
<dd>How many pieces of IO were submitting in a single submit
call. Each entry denotes that amount and below, until
the previous entry - eg, 8=100% mean that we submitted
anywhere in between 5-8 ios per submit call.</dd>
<dt><strong>IO complete=</strong></dt>
<dd>Like the above submit number, but for completions instead.</dd>
<dt><strong>IO issued=</strong></dt>
<dd>The number of read/write requests issued, and how many
of them were short.</dd>
<dt><strong>IO latencies=</strong></dt>
<dd>The distribution of IO completion latencies. This is the
time from when IO leaves fio and when it gets completed.
The numbers follow the same pattern as the IO depths,
meaning that 2=1.6% means that 1.6% of the IO completed
within 2 msecs, 20=12.8% means that 12.8% of the IO
took more than 10 msecs, but less than (or equal to) 20 msecs.</dd>
</dl>
<p>After each client has been listed, the group statistics are printed. They
will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Run</span> <span class="n">status</span> <span class="n">group</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">all</span> <span class="n">jobs</span><span class="p">):</span>
   <span class="n">READ</span><span class="p">:</span> <span class="n">io</span><span class="o">=</span><span class="mi">64</span><span class="n">MB</span><span class="p">,</span> <span class="n">aggrb</span><span class="o">=</span><span class="mi">22178</span><span class="p">,</span> <span class="n">minb</span><span class="o">=</span><span class="mi">11355</span><span class="p">,</span> <span class="n">maxb</span><span class="o">=</span><span class="mi">11814</span><span class="p">,</span> <span class="n">mint</span><span class="o">=</span><span class="mi">2840</span><span class="n">msec</span><span class="p">,</span> <span class="n">maxt</span><span class="o">=</span><span class="mi">2955</span><span class="n">msec</span>
  <span class="n">WRITE</span><span class="p">:</span> <span class="n">io</span><span class="o">=</span><span class="mi">64</span><span class="n">MB</span><span class="p">,</span> <span class="n">aggrb</span><span class="o">=</span><span class="mi">1302</span><span class="p">,</span> <span class="n">minb</span><span class="o">=</span><span class="mi">666</span><span class="p">,</span> <span class="n">maxb</span><span class="o">=</span><span class="mi">669</span><span class="p">,</span> <span class="n">mint</span><span class="o">=</span><span class="mi">50093</span><span class="n">msec</span><span class="p">,</span> <span class="n">maxt</span><span class="o">=</span><span class="mi">50320</span><span class="n">msec</span>
</pre></div>
</div>
<p>For each data direction, it prints:</p>
<dl class="docutils">
<dt><strong>io=</strong></dt>
<dd>Number of megabytes io performed.</dd>
<dt><strong>aggrb=</strong></dt>
<dd>Aggregate bandwidth of threads in this group.</dd>
<dt><strong>minb=</strong></dt>
<dd>The minimum average bandwidth a thread saw.</dd>
<dt><strong>maxb=</strong></dt>
<dd>The maximum average bandwidth a thread saw.</dd>
<dt><strong>mint=</strong></dt>
<dd>The smallest runtime of the threads in that group.</dd>
<dt><strong>maxt=</strong></dt>
<dd>The longest runtime of the threads in that group.</dd>
</dl>
<p>And finally, the disk statistics are printed. They will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Disk</span> <span class="n">stats</span> <span class="p">(</span><span class="n">read</span><span class="o">/</span><span class="n">write</span><span class="p">):</span>
  <span class="n">sda</span><span class="p">:</span> <span class="n">ios</span><span class="o">=</span><span class="mi">16398</span><span class="o">/</span><span class="mi">16511</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="mi">30</span><span class="o">/</span><span class="mi">162</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="mi">6853</span><span class="o">/</span><span class="mi">819634</span><span class="p">,</span> <span class="n">in_queue</span><span class="o">=</span><span class="mi">826487</span><span class="p">,</span> <span class="n">util</span><span class="o">=</span><span class="mf">100.00</span><span class="o">%</span>
</pre></div>
</div>
<p>Each value is printed for both reads and writes, with reads first. The
numbers denote:</p>
<dl class="docutils">
<dt><strong>ios=</strong></dt>
<dd>Number of ios performed by all groups.</dd>
<dt><strong>merge=</strong></dt>
<dd>Number of merges io the io scheduler.</dd>
<dt><strong>ticks=</strong></dt>
<dd>Number of ticks we kept the disk busy.</dd>
<dt><strong>io_queue=</strong></dt>
<dd>Total time spent in the disk queue.</dd>
<dt><strong>util=</strong></dt>
<dd>The disk utilization. A value of 100% means we kept the disk
busy constantly, 50% would be a disk idling half of the time.</dd>
</dl>
<p>It is also possible to get fio to dump the current output while it is
running, without terminating the job. To do that, send fio the USR1 signal.
You can also get regularly timed dumps by using the <cite>&#8211;status-interval</cite>
parameter, or by creating a file in /tmp named fio-dump-status. If fio
sees this file, it will unlink it and dump the current output status.</p>
</div>
<div class="section" id="terse-output">
<h2>2.7. Terse output<a class="headerlink" href="#terse-output" title="Permalink to this headline">¶</a></h2>
<p>For scripted usage where you typically want to generate tables or graphs
of the results, fio can output the results in a semicolon separated format.
The format is one long line of values, such as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="p">;</span><span class="n">card0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">7139336</span><span class="p">;</span><span class="mi">121836</span><span class="p">;</span><span class="mi">60004</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">10109</span><span class="p">;</span><span class="mf">27.932460</span><span class="p">;</span><span class="mf">116.933948</span><span class="p">;</span><span class="mi">220</span><span class="p">;</span><span class="mi">126861</span><span class="p">;</span><span class="mf">3495.446807</span><span class="p">;</span><span class="mf">1085.368601</span><span class="p">;</span><span class="mi">226</span><span class="p">;</span><span class="mi">126864</span><span class="p">;</span><span class="mf">3523.635629</span><span class="p">;</span><span class="mf">1089.012448</span><span class="p">;</span><span class="mi">24063</span><span class="p">;</span><span class="mi">99944</span><span class="p">;</span><span class="mf">50.275485</span><span class="o">%</span><span class="p">;</span><span class="mf">59818.274627</span><span class="p">;</span><span class="mf">5540.657370</span><span class="p">;</span><span class="mi">7155060</span><span class="p">;</span><span class="mi">122104</span><span class="p">;</span><span class="mi">60004</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">8338</span><span class="p">;</span><span class="mf">29.086342</span><span class="p">;</span><span class="mf">117.839068</span><span class="p">;</span><span class="mi">388</span><span class="p">;</span><span class="mi">128077</span><span class="p">;</span><span class="mf">5032.488518</span><span class="p">;</span><span class="mf">1234.785715</span><span class="p">;</span><span class="mi">391</span><span class="p">;</span><span class="mi">128085</span><span class="p">;</span><span class="mf">5061.839412</span><span class="p">;</span><span class="mf">1236.909129</span><span class="p">;</span><span class="mi">23436</span><span class="p">;</span><span class="mi">100928</span><span class="p">;</span><span class="mf">50.287926</span><span class="o">%</span><span class="p">;</span><span class="mf">59964.832030</span><span class="p">;</span><span class="mf">5644.844189</span><span class="p">;</span><span class="mf">14.595833</span><span class="o">%</span><span class="p">;</span><span class="mf">19.394167</span><span class="o">%</span><span class="p">;</span><span class="mi">123706</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">7313</span><span class="p">;</span><span class="mf">0.1</span><span class="o">%</span><span class="p">;</span><span class="mf">0.1</span><span class="o">%</span><span class="p">;</span><span class="mf">0.1</span><span class="o">%</span><span class="p">;</span><span class="mf">0.1</span><span class="o">%</span><span class="p">;</span><span class="mf">0.1</span><span class="o">%</span><span class="p">;</span><span class="mf">0.1</span><span class="o">%</span><span class="p">;</span><span class="mf">100.0</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.01</span><span class="o">%</span><span class="p">;</span><span class="mf">0.02</span><span class="o">%</span><span class="p">;</span><span class="mf">0.05</span><span class="o">%</span><span class="p">;</span><span class="mf">0.16</span><span class="o">%</span><span class="p">;</span><span class="mf">6.04</span><span class="o">%</span><span class="p">;</span><span class="mf">40.40</span><span class="o">%</span><span class="p">;</span><span class="mf">52.68</span><span class="o">%</span><span class="p">;</span><span class="mf">0.64</span><span class="o">%</span><span class="p">;</span><span class="mf">0.01</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.01</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span><span class="p">;</span><span class="mf">0.00</span><span class="o">%</span>
<span class="n">A</span> <span class="n">description</span> <span class="n">of</span> <span class="n">this</span> <span class="n">job</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
</pre></div>
</div>
<p>The job description (if provided) follows on a second line.</p>
<p>To enable terse output, use the <cite>&#8211;minimal</cite> command line option. The first
value is the version of the terse output format. If the output has to
be changed for some reason, this number will be incremented by 1 to
signify that change.</p>
<p>Split up, the format is as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">terse</span> <span class="n">version</span><span class="p">,</span> <span class="n">fio</span> <span class="n">version</span><span class="p">,</span> <span class="n">jobname</span><span class="p">,</span> <span class="n">groupid</span><span class="p">,</span> <span class="n">error</span>
<span class="n">READ</span> <span class="n">status</span><span class="p">:</span>
        <span class="n">Total</span> <span class="n">IO</span> <span class="p">(</span><span class="n">KB</span><span class="p">),</span> <span class="n">bandwidth</span> <span class="p">(</span><span class="n">KB</span><span class="o">/</span><span class="n">sec</span><span class="p">),</span> <span class="n">IOPS</span><span class="p">,</span> <span class="n">runtime</span> <span class="p">(</span><span class="n">msec</span><span class="p">)</span>
        <span class="n">Submission</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span> <span class="p">(</span><span class="n">usec</span><span class="p">)</span>
        <span class="n">Completion</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span> <span class="p">(</span><span class="n">usec</span><span class="p">)</span>
        <span class="n">Completion</span> <span class="n">latency</span> <span class="n">percentiles</span><span class="p">:</span> <span class="mi">20</span> <span class="n">fields</span> <span class="p">(</span><span class="n">see</span> <span class="n">below</span><span class="p">)</span>
        <span class="n">Total</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span> <span class="p">(</span><span class="n">usec</span><span class="p">)</span>
        <span class="n">Bw</span> <span class="p">(</span><span class="n">KB</span><span class="o">/</span><span class="n">s</span><span class="p">):</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">aggregate</span> <span class="n">percentage</span> <span class="n">of</span> <span class="n">total</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span>
<span class="n">WRITE</span> <span class="n">status</span><span class="p">:</span>
        <span class="n">Total</span> <span class="n">IO</span> <span class="p">(</span><span class="n">KB</span><span class="p">),</span> <span class="n">bandwidth</span> <span class="p">(</span><span class="n">KB</span><span class="o">/</span><span class="n">sec</span><span class="p">),</span> <span class="n">IOPS</span><span class="p">,</span> <span class="n">runtime</span> <span class="p">(</span><span class="n">msec</span><span class="p">)</span>
        <span class="n">Submission</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span> <span class="p">(</span><span class="n">usec</span><span class="p">)</span>
        <span class="n">Completion</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">(</span><span class="n">usec</span><span class="p">)</span>
        <span class="n">Completion</span> <span class="n">latency</span> <span class="n">percentiles</span><span class="p">:</span> <span class="mi">20</span> <span class="n">fields</span> <span class="p">(</span><span class="n">see</span> <span class="n">below</span><span class="p">)</span>
        <span class="n">Total</span> <span class="n">latency</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span> <span class="p">(</span><span class="n">usec</span><span class="p">)</span>
        <span class="n">Bw</span> <span class="p">(</span><span class="n">KB</span><span class="o">/</span><span class="n">s</span><span class="p">):</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">aggregate</span> <span class="n">percentage</span> <span class="n">of</span> <span class="n">total</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span>
<span class="n">CPU</span> <span class="n">usage</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">context</span> <span class="n">switches</span><span class="p">,</span> <span class="n">major</span> <span class="n">faults</span><span class="p">,</span> <span class="n">minor</span> <span class="n">faults</span>
<span class="n">IO</span> <span class="n">depths</span><span class="p">:</span> <span class="o">&lt;=</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="o">&gt;=</span><span class="mi">64</span>
<span class="n">IO</span> <span class="n">latencies</span> <span class="n">microseconds</span><span class="p">:</span> <span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">750</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">IO</span> <span class="n">latencies</span> <span class="n">milliseconds</span><span class="p">:</span> <span class="o">&lt;=</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">750</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="o">&gt;=</span><span class="mi">2000</span>
<span class="n">Disk</span> <span class="n">utilization</span><span class="p">:</span> <span class="n">Disk</span> <span class="n">name</span><span class="p">,</span> <span class="n">Read</span> <span class="n">ios</span><span class="p">,</span> <span class="n">write</span> <span class="n">ios</span><span class="p">,</span>
                  <span class="n">Read</span> <span class="n">merges</span><span class="p">,</span> <span class="n">write</span> <span class="n">merges</span><span class="p">,</span>
                  <span class="n">Read</span> <span class="n">ticks</span><span class="p">,</span> <span class="n">write</span> <span class="n">ticks</span><span class="p">,</span>
                  <span class="n">Time</span> <span class="n">spent</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">,</span> <span class="n">disk</span> <span class="n">utilization</span> <span class="n">percentage</span>
<span class="n">Additional</span> <span class="n">Info</span> <span class="p">(</span><span class="n">dependent</span> <span class="n">on</span> <span class="n">continue_on_error</span><span class="p">,</span> <span class="n">default</span> <span class="n">off</span><span class="p">):</span> <span class="n">total</span> <span class="c1"># errors, first error code</span>

<span class="n">Additional</span> <span class="n">Info</span> <span class="p">(</span><span class="n">dependent</span> <span class="n">on</span> <span class="n">description</span> <span class="n">being</span> <span class="nb">set</span><span class="p">):</span> <span class="n">Text</span> <span class="n">description</span>
</pre></div>
</div>
<p>Completion latency percentiles can be a grouping of up to 20 sets, so
for the terse output fio writes all of them. Each field will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.00</span><span class="o">%=</span><span class="mi">6112</span>
</pre></div>
</div>
<p>which is the Xth percentile, and the usec latency associated with it.</p>
<p>For disk utilization, all disks used by fio are shown. So for each disk
there will be a disk utilization section.</p>
</div>
<div class="section" id="trace-file-format">
<h2>2.8. Trace file format<a class="headerlink" href="#trace-file-format" title="Permalink to this headline">¶</a></h2>
<p>There are two trace file format that you can encounter. The older (v1) format
is unsupported since version 1.20-rc3 (March 2008). It will still be described
below in case that you get an old trace and want to understand it.</p>
<p>In any case the trace is a simple text file with a single action per line.</p>
<div class="section" id="trace-file-format-v1">
<h3>2.8.1. Trace file format v1<a class="headerlink" href="#trace-file-format-v1" title="Permalink to this headline">¶</a></h3>
<p>Each line represents a single io action in the following format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span>
</pre></div>
</div>
<p>where <cite>rw=0/1</cite> for read/write, and the offset and length entries being in bytes.</p>
<p>This format is not supported in Fio versions =&gt; 1.20-rc3.</p>
</div>
<div class="section" id="trace-file-format-v2">
<h3>2.8.2. Trace file format v2<a class="headerlink" href="#trace-file-format-v2" title="Permalink to this headline">¶</a></h3>
<p>The second version of the trace file format was added in Fio version 1.17.
It allows to access more then one file per trace and has a bigger set of
possible file actions.</p>
<p>The first line of the trace file has to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fio</span> <span class="n">version</span> <span class="mi">2</span> <span class="n">iolog</span>
</pre></div>
</div>
<p>Following this can be lines in two different formats, which are described below.</p>
<p>The file management format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="n">action</span>
</pre></div>
</div>
<p>The filename is given as an absolute path. The action can be one of these:</p>
<dl class="docutils">
<dt><strong>add</strong></dt>
<dd>Add the given filename to the trace</dd>
<dt><strong>open</strong></dt>
<dd>Open the file with the given filename. The filename has to have
been added with the add action before.</dd>
<dt><strong>close</strong></dt>
<dd>Close the file with the given filename. The file has to have been
opened before.</dd>
</dl>
<p>The file io action format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="n">action</span> <span class="n">offset</span> <span class="n">length</span>
</pre></div>
</div>
<p>The filename is given as an absolute path, and has to have been added and opened
before it can be used with this format. The offset and length are given in
bytes. The action can be one of these:</p>
<dl class="docutils">
<dt><strong>wait</strong></dt>
<dd>Wait for &#8216;offset&#8217; microseconds. Everything below 100 is discarded.
The time is relative to the previous wait statement.</dd>
<dt><strong>read</strong></dt>
<dd>Read &#8216;length&#8217; bytes beginning from &#8216;offset&#8217;</dd>
<dt><strong>write</strong></dt>
<dd>Write &#8216;length&#8217; bytes beginning from &#8216;offset&#8217;</dd>
<dt><strong>sync</strong></dt>
<dd><cite>fsync()</cite> the file</dd>
<dt><strong>datasync</strong></dt>
<dd><cite>fdatasync()</cite> the file</dd>
<dt><strong>trim</strong></dt>
<dd>trim the given file from the given &#8216;offset&#8217; for &#8216;length&#8217; bytes</dd>
</dl>
</div>
</div>
<div class="section" id="cpu-idleness-profiling">
<h2>2.9. CPU idleness profiling<a class="headerlink" href="#cpu-idleness-profiling" title="Permalink to this headline">¶</a></h2>
<p>In some cases, we want to understand CPU overhead in a test. For example,
we test patches for the specific goodness of whether they reduce CPU usage.
fio implements a balloon approach to create a thread per CPU that runs at
idle priority, meaning that it only runs when nobody else needs the cpu.
By measuring the amount of work completed by the thread, idleness of each
CPU can be derived accordingly.</p>
<p>An unit work is defined as touching a full page of unsigned characters. Mean
and standard deviation of time to complete an unit work is reported in &#8220;unit
work&#8221; section. Options can be chosen to report detailed percpu idleness or
overall system idleness by aggregating percpu stats.</p>
</div>
<div class="section" id="verification-and-triggers">
<h2>2.10. Verification and triggers<a class="headerlink" href="#verification-and-triggers" title="Permalink to this headline">¶</a></h2>
<p>Fio is usually run in one of two ways, when data verification is done. The
first is a normal write job of some sort with verify enabled. When the
write phase has completed, fio switches to reads and verifies everything
it wrote. The second model is running just the write phase, and then later
on running the same job (but with reads instead of writes) to repeat the
same IO patterns and verify the contents. Both of these methods depend
on the write phase being completed, as fio otherwise has no idea how much
data was written.</p>
<p>With verification triggers, fio supports dumping the current write state
to local files. Then a subsequent read verify workload can load this state
and know exactly where to stop. This is useful for testing cases where
power is cut to a server in a managed fashion, for instance.</p>
<p>A verification trigger consists of two things:</p>
<ol class="arabic simple">
<li>Storing the write state of each job</li>
<li>Executing a trigger command</li>
</ol>
<p>The write state is relatively small, on the order of hundreds of bytes
to single kilobytes. It contains information on the number of completions
done, the last X completions, etc.</p>
<p>A trigger is invoked either through creation (&#8216;touch&#8217;) of a specified
file in the system, or through a timeout setting. If fio is run with
<a class="reference internal" href="README.html#cmdoption--trigger-file"><code class="xref std std-option docutils literal"><span class="pre">--trigger-file</span></code></a> = <code class="docutils literal"><span class="pre">/tmp/trigger-file</span></code>, then it will continually check for
the existence of <code class="docutils literal"><span class="pre">/tmp/trigger-file</span></code>. When it sees this file, it will
fire off the trigger (thus saving state, and executing the trigger
command).</p>
<p>For client/server runs, there&#8217;s both a local and remote trigger. If
fio is running as a server backend, it will send the job states back
to the client for safe storage, then execute the remote trigger, if
specified. If a local trigger is specified, the server will still send
back the write state, but the client will then execute the trigger.</p>
<div class="section" id="verification-trigger-example">
<h3>2.10.1. Verification trigger example<a class="headerlink" href="#verification-trigger-example" title="Permalink to this headline">¶</a></h3>
<p>Lets say we want to run a powercut test on the remote machine &#8216;server&#8217;.
Our write workload is in write-test.fio. We want to cut power to &#8216;server&#8217;
at some point during the run, and we&#8217;ll run this test from the safety
or our local machine, &#8216;localbox&#8217;. On the server, we&#8217;ll start the fio
backend normally:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>server# fio --server

and on the client, we&#39;ll fire off the workload:

localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger-remote=&quot;bash -c \&quot;echo b &gt; /proc/sysrq-triger\&quot;&quot;

We set /tmp/my-trigger as the trigger file, and we tell fio to execute

echo b &gt; /proc/sysrq-trigger
</pre></div>
</div>
<p>on the server once it has received the trigger and sent us the write
state. This will work, but it&#8217;s not _really_ cutting power to the server,
it&#8217;s merely abruptly rebooting it. If we have a remote way of cutting
power to the server through IPMI or similar, we could do that through
a local trigger command instead. Lets assume we have a script that does
IPMI reboot of a given hostname, ipmi-reboot. On localbox, we could
then have run fio with a local trigger instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger=&quot;ipmi-reboot server&quot;
</pre></div>
</div>
<p>For this case, fio would wait for the server to send us the write state,
then execute &#8216;ipmi-reboot server&#8217; when that happened.</p>
</div>
<div class="section" id="loading-verify-state">
<h3>2.10.2. Loading verify state<a class="headerlink" href="#loading-verify-state" title="Permalink to this headline">¶</a></h3>
<p>To load store write state, read verification job file must contain
the verify_state_load option. If that is set, fio will load the previously
stored state. For a local fio run this is done by loading the files directly,
and on a client/server run, the server backend will ask the client to send
the files over and load them from there.</p>
</div>
</div>
<div class="section" id="log-file-formats">
<h2>2.11. Log File Formats<a class="headerlink" href="#log-file-formats" title="Permalink to this headline">¶</a></h2>
<p>Fio supports a variety of log file formats, for logging latencies, bandwidth,
and IOPS. The logs share a common format, which looks like this:</p>
<p>time (msec), value, data direction, offset</p>
<p>Time for the log entry is always in milliseconds. The value logged depends
on the type of log, it will be one of the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Latency</span> <span class="n">log</span>             <span class="n">Value</span> <span class="ow">is</span> <span class="n">latency</span> <span class="ow">in</span> <span class="n">usecs</span>
<span class="n">Bandwidth</span> <span class="n">log</span>           <span class="n">Value</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">KB</span><span class="o">/</span><span class="n">sec</span>
<span class="n">IOPS</span> <span class="n">log</span>                <span class="n">Value</span> <span class="ow">is</span> <span class="n">IOPS</span>
</pre></div>
</div>
<p>Data direction is one of the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">0</span>                       <span class="n">IO</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">READ</span>
<span class="mi">1</span>                       <span class="n">IO</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">WRITE</span>
<span class="mi">2</span>                       <span class="n">IO</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">TRIM</span>
</pre></div>
</div>
<p>The offset is the offset, in bytes, from the start of the file, for that
particular IO. The logging of the offset can be toggled with <a class="reference internal" href="#cmdoption-arg-log_offset"><code class="xref std std-option docutils literal"><span class="pre">log_offset</span></code></a></p>
<p>If windowed logging is enabled through <a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> then fio doesn&#8217;t log
individual IOs. Instead of logs the average values over the specified
period of time. Since &#8216;data direction&#8217; and &#8216;offset&#8217; are per-IO values,
they aren&#8217;t applicable if windowed logging is enabled. If windowed logging
is enabled and <a class="reference internal" href="#cmdoption-arg-log_max_value"><code class="xref std std-option docutils literal"><span class="pre">log_max_value</span></code></a> is set, then fio logs maximum values in
that window instead of averages.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. HOWTO</a><ul>
<li><a class="reference internal" href="#overview-and-history">2.1. Overview and history</a></li>
<li><a class="reference internal" href="#how-fio-works">2.2. How fio works</a></li>
<li><a class="reference internal" href="#running-fio">2.3. Running fio</a></li>
<li><a class="reference internal" href="#job-file-format">2.4. Job file format</a><ul>
<li><a class="reference internal" href="#environment-variables">2.4.1. Environment variables</a></li>
<li><a class="reference internal" href="#reserved-keywords">2.4.2. Reserved keywords</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-list-of-parameters">2.5. Detailed list of parameters</a></li>
<li><a class="reference internal" href="#interpreting-the-output">2.6. Interpreting the output</a></li>
<li><a class="reference internal" href="#terse-output">2.7. Terse output</a></li>
<li><a class="reference internal" href="#trace-file-format">2.8. Trace file format</a><ul>
<li><a class="reference internal" href="#trace-file-format-v1">2.8.1. Trace file format v1</a></li>
<li><a class="reference internal" href="#trace-file-format-v2">2.8.2. Trace file format v2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpu-idleness-profiling">2.9. CPU idleness profiling</a></li>
<li><a class="reference internal" href="#verification-and-triggers">2.10. Verification and triggers</a><ul>
<li><a class="reference internal" href="#verification-trigger-example">2.10.1. Verification trigger example</a></li>
<li><a class="reference internal" href="#loading-verify-state">2.10.2. Loading verify state</a></li>
</ul>
</li>
<li><a class="reference internal" href="#log-file-formats">2.11. Log File Formats</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="README.html" title="previous chapter">1. README</a></li>
      <li>Next: <a href="TODO.html" title="next chapter">3. GFIO TODO</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/HOWTO.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Jens Axboe <axboe@kernel.dk>.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/HOWTO.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>